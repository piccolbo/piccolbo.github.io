<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Facebook Prime Bits</title>
  <meta name="description" content="This is one of Facebook job candidate puzzles. Given a range [a,b] of positive integer numbers, test for the primality of the number of 1 bits in the binary ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://piccolboni.info/2007/11/facebook-prime-bits.html">
  <link rel="alternate" type="application/rss+xml" title="Antonio Piccolboni" href="http://piccolboni.info/atom.xml" />
  <link rel="shortcut icon" type="image/png" href="gravatar32.png?v=3">
  <script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
  </script>
  <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Facebook Prime Bits - Antonio Piccolboni</title>
<meta property="og:title" content="Facebook Prime Bits" />
<meta name="description" content="This is one of Facebook job candidate puzzles. Given a range [a,b] of positive integer numbers, test for the primality of the number of 1 bits in the binary representation of each number, and do so in  O(n)  where n is b -  a.Unfortunately the puzzle goes on to assume that n is a 64 bit integer, and that makes asymptotic analysis quite meaningless, so I will discard this assumption for now and comment on it later. The naive solution loops through the given range converting each number to its binary representation, counting 1 bits and testing primality. The complexity of this algorithm is O((b-a) log(b)), using the polynomial time deterministic primality test of Agrawal,  Saxena and Kayal. One might think that the primality test is the hard part of the algorithm, but the numbers to be tested are  pretty small. The representation of b takes log(b) bits. The number of 1 bits in it is at most, of course, log(b) and that can be represented with log(log(b)) bits, and the ASK algorithm is polynomial w.r.t to the size of its input, or poly(log(log(b))). So is it possible to get rid of the log(b) term depending on counting the bits in the binary representation of a number? The answer is in the following functions and is positive. The main idea is to avoid recomputing the same partial sum of bits over and over again. Imagine a trie or prefix tree of the binary representations of all the numbers in the range. Imagine a traversal in preorder that is performed while keeping a count of 1 bits seen so far between the root (most significant bit) and the current position. Every time a leaf (complete number) is reached, the results are extended with one item.use strict;sub countbits {return f(@_, 0, []);}sub f {my ($a, $b, $count, $retv) = @_;if ($a != $b) {my $k = int(log2($b));if (topbits($a, $k) == topbits($b, $k)) {return  f(bottombits($a, $k),bottombits($b, $k),$count + topbits($a, $k),$retv );}else {f(bottombits($a, $k),  2**$k - 1,$count,$retv);return  f(0,bottombits($b, $k),$count + 1,  $retv);}}else {push @$retv, $count + g($a);return $retv;}}sub g {my $a = shift;return ($a == 0 ? 0 :$a % 2 + g ($a &gt;&gt; 1));}sub topbits{my ($a, $k) = @_;return $a &gt;&gt; $k;}sub bottombits{my ($a, $k) = @_;return $a % 2**$k;}sub log2 {my $n = shift;return log($n)/log(2);}The shift and mod operations are not strictly constant time, but they are used just to select the first bit and the remaining bits, so that can be done in constant time but I thought the function was clearer this way. The worst case analysis assumes that the double recursive call is always performed and relies on the fact that the number of significant digits is decreasing by one with each level of recursion. G is of course O(log(a)). This establishes a O((b-a)+log(a)) bound. So there is a log(a) term in there, and we still need the primality test, either precomputed (O((b-a)+log(a)+log(b)poly(log(log(b)))) total time) or performed on each number in O((b-a) poly(log(log(b)))). Neither is superior depending on a. So one can not strictly achieve O(b-a) as claimed by the Facebook gurus. This is not a limitation of my approach. If it were possible, it would imply for a=b that primality can be tested in constant time. Two friends of mine and programming superstars both  used the additional assumption  of 64 bit numbers to consider log(b) &lt;=64 and therefore constant as we were discussing this problem. Personally, I think mixing finite and asymptotic analysis doesn&#39;t really help making things more clear and ridding oneself of a log(b) factor when  it can be as large as 64 can have practical consequences. Actually, I think this is a great example that asymptotic analysis is insightful. Still it would be nice to make sure that my algorithm doesn&#39;t have horrible constants in its time complexity function. This is left as an exercise for the reader (suggestion: use generating functions). " />
<meta property="og:description" content="This is one of Facebook job candidate puzzles. Given a range [a,b] of positive integer numbers, test for the primality of the number of 1 bits in the binary representation of each number, and do so in  O(n)  where n is b -  a.Unfortunately the puzzle goes on to assume that n is a 64 bit integer, and that makes asymptotic analysis quite meaningless, so I will discard this assumption for now and comment on it later. The naive solution loops through the given range converting each number to its binary representation, counting 1 bits and testing primality. The complexity of this algorithm is O((b-a) log(b)), using the polynomial time deterministic primality test of Agrawal,  Saxena and Kayal. One might think that the primality test is the hard part of the algorithm, but the numbers to be tested are  pretty small. The representation of b takes log(b) bits. The number of 1 bits in it is at most, of course, log(b) and that can be represented with log(log(b)) bits, and the ASK algorithm is polynomial w.r.t to the size of its input, or poly(log(log(b))). So is it possible to get rid of the log(b) term depending on counting the bits in the binary representation of a number? The answer is in the following functions and is positive. The main idea is to avoid recomputing the same partial sum of bits over and over again. Imagine a trie or prefix tree of the binary representations of all the numbers in the range. Imagine a traversal in preorder that is performed while keeping a count of 1 bits seen so far between the root (most significant bit) and the current position. Every time a leaf (complete number) is reached, the results are extended with one item.use strict;sub countbits {return f(@_, 0, []);}sub f {my ($a, $b, $count, $retv) = @_;if ($a != $b) {my $k = int(log2($b));if (topbits($a, $k) == topbits($b, $k)) {return  f(bottombits($a, $k),bottombits($b, $k),$count + topbits($a, $k),$retv );}else {f(bottombits($a, $k),  2**$k - 1,$count,$retv);return  f(0,bottombits($b, $k),$count + 1,  $retv);}}else {push @$retv, $count + g($a);return $retv;}}sub g {my $a = shift;return ($a == 0 ? 0 :$a % 2 + g ($a &gt;&gt; 1));}sub topbits{my ($a, $k) = @_;return $a &gt;&gt; $k;}sub bottombits{my ($a, $k) = @_;return $a % 2**$k;}sub log2 {my $n = shift;return log($n)/log(2);}The shift and mod operations are not strictly constant time, but they are used just to select the first bit and the remaining bits, so that can be done in constant time but I thought the function was clearer this way. The worst case analysis assumes that the double recursive call is always performed and relies on the fact that the number of significant digits is decreasing by one with each level of recursion. G is of course O(log(a)). This establishes a O((b-a)+log(a)) bound. So there is a log(a) term in there, and we still need the primality test, either precomputed (O((b-a)+log(a)+log(b)poly(log(log(b)))) total time) or performed on each number in O((b-a) poly(log(log(b)))). Neither is superior depending on a. So one can not strictly achieve O(b-a) as claimed by the Facebook gurus. This is not a limitation of my approach. If it were possible, it would imply for a=b that primality can be tested in constant time. Two friends of mine and programming superstars both  used the additional assumption  of 64 bit numbers to consider log(b) &lt;=64 and therefore constant as we were discussing this problem. Personally, I think mixing finite and asymptotic analysis doesn&#39;t really help making things more clear and ridding oneself of a log(b) factor when  it can be as large as 64 can have practical consequences. Actually, I think this is a great example that asymptotic analysis is insightful. Still it would be nice to make sure that my algorithm doesn&#39;t have horrible constants in its time complexity function. This is left as an exercise for the reader (suggestion: use generating functions). " />
<link rel="canonical" href="http://piccolboni.info/2007/11/facebook-prime-bits.html" />
<meta property="og:url" content="http://piccolboni.info/2007/11/facebook-prime-bits.html" />
<meta property="og:site_name" content="Antonio Piccolboni" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2007-11-02T00:00:00-07:00" />
<link rel="next" href="http://piccolboni.info/2007/11/facebook-illegal-wiretaps.html" title="Facebook Illegal Wiretaps" />
<link rel="prev" href="http://piccolboni.info/2007/05/projectdescription-lucene-hadoop-wiki.html" title="ProjectDescription - Lucene-hadoop Wiki" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Facebook Prime Bits",
    "datePublished": "2007-11-02T00:00:00-07:00",
    "description": "This is one of Facebook job candidate puzzles. Given a range [a,b] of positive integer numbers, test for the primality of the number of 1 bits in the binary representation of each number, and do so in  O(n)  where n is b -  a.Unfortunately the puzzle goes on to assume that n is a 64 bit integer, and that makes asymptotic analysis quite meaningless, so I will discard this assumption for now and comment on it later. The naive solution loops through the given range converting each number to its binary representation, counting 1 bits and testing primality. The complexity of this algorithm is O((b-a) log(b)), using the polynomial time deterministic primality test of Agrawal,  Saxena and Kayal. One might think that the primality test is the hard part of the algorithm, but the numbers to be tested are  pretty small. The representation of b takes log(b) bits. The number of 1 bits in it is at most, of course, log(b) and that can be represented with log(log(b)) bits, and the ASK algorithm is polynomial w.r.t to the size of its input, or poly(log(log(b))). So is it possible to get rid of the log(b) term depending on counting the bits in the binary representation of a number? The answer is in the following functions and is positive. The main idea is to avoid recomputing the same partial sum of bits over and over again. Imagine a trie or prefix tree of the binary representations of all the numbers in the range. Imagine a traversal in preorder that is performed while keeping a count of 1 bits seen so far between the root (most significant bit) and the current position. Every time a leaf (complete number) is reached, the results are extended with one item.use strict;sub countbits {return f(@_, 0, []);}sub f {my ($a, $b, $count, $retv) = @_;if ($a != $b) {my $k = int(log2($b));if (topbits($a, $k) == topbits($b, $k)) {return  f(bottombits($a, $k),bottombits($b, $k),$count + topbits($a, $k),$retv );}else {f(bottombits($a, $k),  2**$k - 1,$count,$retv);return  f(0,bottombits($b, $k),$count + 1,  $retv);}}else {push @$retv, $count + g($a);return $retv;}}sub g {my $a = shift;return ($a == 0 ? 0 :$a % 2 + g ($a &gt;&gt; 1));}sub topbits{my ($a, $k) = @_;return $a &gt;&gt; $k;}sub bottombits{my ($a, $k) = @_;return $a % 2**$k;}sub log2 {my $n = shift;return log($n)/log(2);}The shift and mod operations are not strictly constant time, but they are used just to select the first bit and the remaining bits, so that can be done in constant time but I thought the function was clearer this way. The worst case analysis assumes that the double recursive call is always performed and relies on the fact that the number of significant digits is decreasing by one with each level of recursion. G is of course O(log(a)). This establishes a O((b-a)+log(a)) bound. So there is a log(a) term in there, and we still need the primality test, either precomputed (O((b-a)+log(a)+log(b)poly(log(log(b)))) total time) or performed on each number in O((b-a) poly(log(log(b)))). Neither is superior depending on a. So one can not strictly achieve O(b-a) as claimed by the Facebook gurus. This is not a limitation of my approach. If it were possible, it would imply for a=b that primality can be tested in constant time. Two friends of mine and programming superstars both  used the additional assumption  of 64 bit numbers to consider log(b) &lt;=64 and therefore constant as we were discussing this problem. Personally, I think mixing finite and asymptotic analysis doesn&#39;t really help making things more clear and ridding oneself of a log(b) factor when  it can be as large as 64 can have practical consequences. Actually, I think this is a great example that asymptotic analysis is insightful. Still it would be nice to make sure that my algorithm doesn&#39;t have horrible constants in its time complexity function. This is left as an exercise for the reader (suggestion: use generating functions). ",
    "url": "http://piccolboni.info/2007/11/facebook-prime-bits.html"
  }
</script>
<!-- End Jekyll SEO tag -->
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Antonio Piccolboni</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about">About me</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/contact">Contact</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/projects">Projects</a>
          
        
          
        
          
          <a class="page-link" href="/speaking">Speaking</a>
          
        
          
          <a class="page-link" href="/writing">Writing</a>
          
        
        <a class="page-link" href="https://feedburner.google.com/fb/a/mailverify?uri=piccolboni/qdqo&amp;loc=en_US">Subscribe</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Facebook Prime Bits</h1>
    <p class="post-meta">Nov 2, 2007</p>
  </header>

  <article class="post-content">
    <div class='post'>
<div style="text-align: justify;">This is one of Facebook job candidate puzzles. Given a range [a,b] of positive integer numbers, test for the primality of the number of 1 bits in the binary representation of each number, and do so in  O(n)  where n is b -  a.<br /><a name='more'></a><br />Unfortunately the puzzle goes on to assume that n is a 64 bit integer, and that makes asymptotic analysis quite meaningless, so I will discard this assumption for now and comment on it later. The naive solution loops through the given range converting each number to its binary representation, counting 1 bits and testing primality. The complexity of this algorithm is O((b-a) log(b)), using the polynomial time deterministic primality test of Agrawal,  Saxena and Kayal. One might think that the primality test is the hard part of the algorithm, but the numbers to be tested are  pretty small. The representation of b takes log(b) bits. The number of 1 bits in it is at most, of course, log(b) and that can be represented with log(log(b)) bits, and the ASK algorithm is polynomial w.r.t to the size of its input, or poly(log(log(b))). So is it possible to get rid of the log(b) term depending on counting the bits in the binary representation of a number? The answer is in the following functions and is positive. The main idea is to avoid recomputing the same partial sum of bits over and over again. Imagine a trie or prefix tree of the binary representations of all the numbers in the range. Imagine a traversal in preorder that is performed while keeping a count of 1 bits seen so far between the root (most significant bit) and the current position. Every time a leaf (complete number) is reached, the results are extended with one item.<br /><br /><br /><pre>use strict;<br /><br />sub countbits {<br />return f(@_, 0, []);<br />}<br /><br />sub f {<br />my ($a, $b, $count, $retv) = @_;<br />if ($a != $b) {<br />my $k = int(log2($b));<br />if (topbits($a, $k) == topbits($b, $k)) {<br />return  f(bottombits($a, $k),<br />bottombits($b, $k),<br />$count + topbits($a, $k),<br />$retv );<br />}<br />else {<br />f(bottombits($a, $k),  <br />2**$k - 1,<br />$count,<br />$retv);<br />return  f(0,<br />bottombits($b, $k),<br />$count + 1,  <br />$retv);<br />}<br />}<br />else {<br />push @$retv, $count + g($a);<br />return $retv;<br />}<br />}<br /><br />sub g {<br />my $a = shift;<br />return ($a == 0 ? 0 :$a % 2 + g ($a >> 1));<br />}<br /><br />sub topbits{<br />my ($a, $k) = @_;<br />return $a >> $k;<br />}<br /><br />sub bottombits{<br />my ($a, $k) = @_;<br />return $a % 2**$k;<br />}<br /><br />sub log2 {<br />my $n = shift;<br />return log($n)/log(2);<br />}<br /><br /></pre><br />The shift and mod operations are not strictly constant time, but they are used just to select the first bit and the remaining bits, so that can be done in constant time but I thought the function was clearer this way. The worst case analysis assumes that the double recursive call is always performed and relies on the fact that the number of significant digits is decreasing by one with each level of recursion. G is of course O(log(a)). This establishes a O((b-a)+log(a)) bound. So there is a log(a) term in there, and we still need the primality test, either precomputed (O((b-a)+log(a)+log(b)poly(log(log(b)))) total time) or performed on each number in O((b-a) poly(log(log(b)))). Neither is superior depending on a. So one can not strictly achieve O(b-a) as claimed by the Facebook gurus. This is not a limitation of my approach. If it were possible, it would imply for a=b that primality can be tested in constant time. Two friends of mine and programming superstars both  used the additional assumption  of 64 bit numbers to consider log(b) <=64 and therefore constant as we were discussing this problem. Personally, I think mixing finite and asymptotic analysis doesn't really help making things more clear and ridding oneself of a log(b) factor when  it can be as large as 64 can have practical consequences. Actually, I think this is a great example that asymptotic analysis is insightful. Still it would be nice to make sure that my algorithm doesn't have horrible constants in its time complexity function. This is left as an exercise for the reader (suggestion: use generating functions). </div></div>

  </article>

  <div class="SendComment">
    <a href="mailto:antonio@piccolboni.info?subject=Facebook Prime Bits&body=http://piccolboni.info/2007/11/facebook-prime-bits.html" target="_top">Email the author</a> or <a href="http://via.hypothes.is/http://piccolboni.info//2007/11/facebook-prime-bits.html">annotate with hypothes.is</a>
  </div>
  <div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */

var disqus_config = function () {
    this.page.url = "http://piccolboni.info//2007/11/facebook-prime-bits.html";
    this.page.identifier = "/2007/11/facebook-prime-bits";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//piccolbo.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>

      </div>
    </div>
    <footer class="site-footer">

  <div class="wrapper">

    <div class="PageNavigation">
      
        <a class="prev" href="/2007/05/projectdescription-lucene-hadoop-wiki.html">&laquo;    ProjectDescription - Lucene-hadoop Wiki</a>
      
      
        <a class="next" href="/2007/11/facebook-illegal-wiretaps.html">Facebook Illegal Wiretaps &raquo;</a>
      
    </div>

  </div>

</footer>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-7018175-5', 'piccolboni.info');
  ga('send', 'pageview');

</script>

  </body>

</html>
