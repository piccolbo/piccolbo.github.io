<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Looking for a map reduce language</title>
  <meta name="description" content="On a quest for an elegant and effective map reduce language, I went through a number of options and put together some considerations. And the winner is …Upda...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://piccolboni.info/2011/04/looking-for-map-reduce-language.html">
  <link rel="alternate" type="application/rss+xml" title="Antonio Piccolboni" href="http://piccolboni.info/atom.xml" />
  <link rel="shortcut icon" type="image/png" href="gravatar32.png?v=3">
  <script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
  </script>
  <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Looking for a map reduce language - Antonio Piccolboni</title>
<meta property="og:title" content="Looking for a map reduce language" />
<meta name="description" content="On a quest for an elegant and effective map reduce language, I went through a number of options and put together some considerations. And the winner is …Update: since writing this post, I was approached by Revolution Analytics to write yet another map reduce library, this time for R, and it is, of course, my new favorite. Check it out!In a couple of blog entries from my personal blog I described some map-reduce algorithms for statistical and graph problems and sketched their implementation using pseudo-code. Pseudo-code has two problems: not everybody agrees on what a statement means and it doesn&#39;t run, so you can&#39;t test it or use it. Real programming languages on the other hand tend to obscure the logic of a program with unnecessary detail and have other issues that hinder readability, the reason why people resort to pseudo-code. But there is more to it than just aesthetics. Conciseness of code is related to programming abstractions, constructs that achieve higher generality and remove unnecessary detail; to reuse, whereby the same code is used in different contexts, reducing total program size; and even testing, that is concise programs can be tested more easily. In short, short is better. The elegance of less is hardly my own or a software engineering discovery. As Antoine de Saint-Exupery, French writer and aviator, so eloquently put it :Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.Unfortunately, in some circles, dull, predictable, repetitive code is considered simpler than short and to the point code, or at least tolerable. From java.util.Arrays:478     /*479      * The code for each of the seven primitive types is largely identical.480      * C&#39;est la vie.481      */In this case, repetition gets a free pass in exchange for efficiency. Very expressive languages tend to exact a higher toll on resources, and the different map-reduce environments we will look into are no exception.I will present for each language or library the implementation of a word count program, lifted from its documentation, since this has become sort of the &quot;Hello World&quot; for map reduce. I don&#39;t think such a simple program is the ultimate test of the quality of a language, so this is just to give a taste of the language. What I am most interested in is:Can I write reasonably concise, abstract programs in this language or library?Can I write the &quot;inside&quot; of map reduce, that is the code for the mapper and the reducer, as well as the &quot;outside&quot;, the logic that decides which map reduce jobs to run?Is it general? Can I write any map-reduce program, including programs that require multiple map-reduce jobs, including the case of a data dependent number and type of jobs?Java Hadoop This is the original, the real thing, the current performance champion and what &quot;real men&quot; write in. It is also the most mature of the different options. But take a look:public static class MapClass extends MapReduceBase public class WordCount {     public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {       private final static IntWritable one = new IntWritable(1);              private Text word = new Text();        public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         String line = value.toString();         StringTokenizer tokenizer = new StringTokenizer(line);         while (tokenizer.hasMoreTokens()) {           word.set(tokenizer.nextToken());           output.collect(word, one);         }       }     }      public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {       public void reduce(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         int sum = 0;         while (values.hasNext()) {           sum += values.next().get();         }         output.collect(key, new IntWritable(sum));       }     }      public static void main(String[] args) throws Exception {       JobConf conf = new JobConf(WordCount.class);       conf.setJobName(&quot;wordcount&quot;);        conf.setOutputKeyClass(Text.class);       conf.setOutputValueClass(IntWritable.class);        conf.setMapperClass(Map.class);       conf.setCombinerClass(Reduce.class);       conf.setReducerClass(Reduce.class);        conf.setInputFormat(TextInputFormat.class);       conf.setOutputFormat(TextOutputFormat.class);        conf.setInputPath(new Path(args[0]));       conf.setOutputPath(new Path(args[1]));        JobClient.runJob(conf);     } } 48 lines to write a word count program (and I stripped the import statements at the top out of mercy)! My favorite line is number 5, a line devoted to redefining the number one. This makes sense in a world where programmer productivity is measured by number of lines of code written or for a production job that runs on a 1,000 node cluster for 5 hours every night, in which case efficiency may trump other considerations. But for a blog, for discussing and enjoying code, anything remotely more interesting than a word count program would not fit the size of an entry but would have to be an attachment, as John Mount did with his painstaking Java/Hadoop implementation of logistic regression. I wonder how many people opened that tar file and read it through and through. Hadoop was started by Doug Cutting and is developed by a large community with a significant group employed at Yahoo.CascadingCascading is a Java library written on top of Hadoop. It enables programming in a dataflow style, with some primitives inspired by SQL (like GroupBy). But according to a person closely related to the project, &quot;it&#39;s still Java, it&#39;s still boilerplate code&quot;. My favorite line is number 18. Remarkably, it trims down the line count for the word count program to half as many as plain Hadoop. I don&#39;t have first hand experience with Cascading, but since there is no or little performance penalty compared to the real thing — depending on programmer skill, it could actually be better — it&#39;s worth a try for production work. Cascading is developed by Chris Wensel at Concurrent.Scheme sourceScheme = new TextLine( new Fields( &quot;line&quot; ) );Tap source = new Hfs( sourceScheme, inputPath );Scheme sinkScheme = new TextLine( new Fields( &quot;word&quot;, &quot;count&quot; ) );Tap sink = new Hfs( sinkScheme, outputPath, SinkMode.REPLACE );Pipe assembly = new Pipe( &quot;wordcount&quot; );String regex = &quot;(?&gt;!\\pL)(?=\\pL)[^ ]*(?&lt;=\\pL)(?!\\pL)&quot;;Function function = new RegexGenerator( new Fields( &quot;word&quot; ), regex );assembly = new Each( assembly, new Fields( &quot;line&quot; ), function );assembly = new GroupBy( assembly, new Fields( &quot;word&quot; ) );Aggregator count = new Count( new Fields( &quot;count&quot; ) );assembly = new Every( assembly, count );Properties properties = new Properties();FlowConnector.setApplicationJarClass( properties, Main.class );FlowConnector flowConnector = new FlowConnector( properties );Flow flow = flowConnector.connect( &quot;word-count&quot;, source, sink, assembly );flow.complete();Pipes — C++C++ fits into the Java environment not without some effort, which is encapsulated in a library called Pipes. The word count program looks more compact than in Java/Hadoop. I&#39;ve read opposite comments on the efficiency of Pipes/C++ vs Hadoop/Java and I suspect it may depend on the specific problem being tackled. Even if I used to be quite proficient in C++, I do not remember fondly the 8000 characters template-induced error messages and I don&#39;t think it is the type of language I would want to use to discuss algorithms or for prototyping. Pipes is developed as part of the Hadoop project.class WordCountMap: public HadoopPipes::Mapper {public:  WordCountMap(HadoopPipes::TaskContext&amp; context){}  void map(HadoopPipes::MapContext&amp; context) {    std::vector&lt;std::string&gt; words =      HadoopUtils::splitString(context.getInputValue(), &quot; &quot;);    for(unsigned int i=0; i &lt; words.size(); ++i) {      context.emit(words[i], &quot;1&quot;);    }  }};class WordCountReduce: public HadoopPipes::Reducer {public:  WordCountReduce(HadoopPipes::TaskContext&amp; context){}  void reduce(HadoopPipes::ReduceContext&amp; context) {    int sum = 0;    while (context.nextValue()) {      sum += HadoopUtils::toInt(context.getInputValue());    }    context.emit(context.getInputKey(), HadoopUtils::toString(sum));  }};int main(int argc, char *argv[]) {  return HadoopPipes::runTask(HadoopPipes::TemplateFactory&lt;WordCountMap,                              WordCountReduce&gt;());}HiveHive is a SQL-like language that is interpreted on top of Hadoop. It can also be combined with small programs written in a variety of languages, to make up for the fact that the language itself is not general purpose. For what it does, it is very concise and expressive, but outside that you need to supplement it with other languages. Case in point, the word count example where two additional scripts are left as an exercise for the reader. Hive started as part of the Hadoop project.FROM(MAP docs.contents USING &#39;tokenizer_script&#39; AS word, cntFROM docsCLUSTER BY word) map_outputREDUCE map_output.word, map_output.cnt USING &#39;count_script&#39; AS word, cnt;PigPig adds to the limitations of Hive the hubris of creating a brand new language, as if creating a new programming language were easy. As you can see, it is inspired by SQL to a degree. It is not a general purpose language as clearly explained here. It interfaces with any JVM based language for custom extensions.A = load &#39;/tmp/bible+shakes.nopunc&#39;;B = foreach A generate flatten(TOKENIZE((chararray)$0)) as word;C = filter B by word matches &#39;\\w+&#39;;D = group C by word;E = foreach D generate COUNT(C) as count, group as word;F = order E by count desc;store F into &#39;/tmp/wc&#39;;Pig development was started at Yahoo.RhipeRhipe is an R package to describe and execute map-reduce jobs. It is reasonably high level and satisfies all the criteria I listed above. It&#39;s not a speed daemon, because of R itself, there are some quirks in the API and it&#39;s still at an initial stage of development, but interesting. rhinit()m &lt;- expression({  y &lt;- strsplit(unlist(map.values),&quot; &quot;)  lapply(y,function(r) rhcollect(r,T))})r &lt;- expression(    pre={      count=0    },    reduce={      count &lt;- sum(as.numeric(unlist(reduce.values)),count)    },post={      rhcollect(reduce.key,count)    })z=rhmr(map=m,reduce=r,comb=T,inout=c(&quot;text&quot;,&quot;sequence&quot;),ifolder=&quot;/tmp/50mil&quot;,ofolder=&#39;/tmp/tof&#39;)rhex(z)Rhipe is developed by Saptarshi Guha at Mozilla.DumboDumbo is a Hadoop library for python, but also imposes a set of tools to run dumbo program. If you look at the word count program in Dumbo, below, it almost looks like pseudo-code! Finally! But there is a serious catch. There can only be a run statement per dumbo-powered program — I asked the author himself after seeing some outlandish looking errors. To coordinate two runs, for instance one that starts based on the output of the first, one has to run separate python programs and go through the unix shell. This is different from static composition of jobs, which is well supported, but not general enough for my purposes. Other options for python include MR Job and pydoop, but I haven&#39;t had time to look into these yet.def mapper(key,value):   for word in value.split(): yield word,1def reducer(key,values):   yield key,sum(values)if __name__ == &quot;__main__&quot;:   import dumbo   dumbo.run(mapper,reducer)Dumbo is developed by Klaas Bosteels at last.fm.CascalogBuilt on top of the already powerful cascading as a domain specific language within Clojure, Cascalog wins the word count conciseness contest with a one-liner. Indeed, word counting is simple enough that a line is all that it should take. But look at what a line:(?&lt;- (stdout) [?word ?count] (sentence ?s) (split ?s :&gt; ?word) (c/ count ?count))It probably looks familiar to anybody who&#39;s familiar with it. Conciseness can become terseness, but once some domain specific concepts have been grasped a terse program such as this might become perfectly clear. It was to me at some point. My misgivings here are more about the JVM-powered revival of LISP in the form of Clojure. LISP has been around some 50-odd years without taking off despite several attempts at its revival (Common LISP, Scheme, Arc and now Clojure). I suspect something is wrong with it, even if popularity is not an accurate gauge of language quality, as BASIC has long proved. Personally, I dislike LISP odd syntax, the widespread use of side effects in a functional language and the poor abstraction that lists represent over RAM, from a performance point of view — indeed LISP variants often add additional data structures, somehow negating the &quot;LIS&quot; part of the language. In the specific case of Clojure, the fact that a compiled language is compiled into an interpreted one, JVM bytecode, combining a slow dev cycle with suboptimal performance, makes me think Clojure users must be glutton for punishment.  Cascalog is  developed by Nathan Marz at Backtype.Final thoughtsAt the end of this by necessity incomplete and unscientific language and library comparison, there is a winner and there isn&#39;t. There isn&#39;t because language comparison is always multidimensional and subjective but also because the intended applications are very different. On the other hand, looking for a general purpose, moderately elegant, not necessarily most efficient, not necessarily mature language for exploration purposes, Rhipe seems to fit the bill pretty nicely. First, it is just a library, which means that one can continue to use the tools he&#39;s familiar with. I found it particularly useful to run map-reduce jobs in the interpreter, inspecting the inputs and outputs of each, an invaluable debugging help — but no, you can not step into a mapper or reducer, I use counters instead to trace what&#39;s going on in there. I also like that one can read and write sequence files with one call, to examine the output of previous jobs and decide what to do next. Additionally since R is a statistical language and Hadoop is the tool of choice for big data analytics, this seems like a natural fit. Personally, I am familiar with both, which helps, and I have used R, in combination with Hive or Hadoop, to do analytics in the past, but not at this level of integration. Since there is nothing like trying a more substantial example than word count to figure out a language pros and cons, stay tuned for a fairly complex example. After that is published, I plan to pose a friendly challenge to experts in the languages and libraries above or other Hadoop related languages and see what an implementation of the same algorithm would look like in their language of choice and learn something from the comparison. Maybe among my &quot;25 readers&quot; there is someone who will take it up.CommentsJeremyNot considering Hadoop Streaming seems like a pretty big omission.Antonio Piccolbonidieswaytoofast, that makes Erlang a good candidate for implementing Hadoop itself. In fact Disco (discoproject.org) is a Hadoop equivalent in Erlang. I am not aware of Hadoop libraries for Erlang.Brian, good point and add scrunch https://github.com/cloudera/crunch/tree/master/scrunch to the mix. This post is getting obsolete pretty quickly, as sign of the frantic activity around Hadoop.Brian SchliningScala? See https://github.com/NICTA/scoobival lines = fromTextFile(&quot;hdfs://in/...&quot;)  val counts = lines.flatMap(_.split(&quot; &quot;))                    .map(word =&gt; (word, 1))                    .groupByKey                    .combine(_+_)  persist(toTextFile(counts, &quot;hdfs://out/...&quot;))dieswaytoofastErrr, Erlang??? The semantics and the inbuilt parallelism would seem to fit the bill quite well, no?AnonymousI prefer ruby with streaming.  Personally, I don&#39;t see the need for any higher-level framework on top of it as it&#39;s already extremely easy to deal with STDIN/STDOUT on its own.Fatal ErrorI think the important thing about UDF&#39;s is what is the user excepted to write versus what is already available? From an end user perspective there is no difference between invoking SENTENCES and any other keyword in the hive syntax. Under the covers, it&#39;s all java anyway, but the point is to abstract people that want to be abstracted while still providing a powerful too.So, yes, I consider it part of the core languageAntonio PiccolboniThanks Fatal Error, I wasn&#39;t aware of the sentences UDF, nor I have written this Hive snippet that comes straight from the documentation. Since this UDF itself is written in a different language, not in Hive, it looks to me you are still supporting the point that you need other languages to integrate and extend Hive, unless you consider the UDF sentences part of the core language, which seems like a stretch to me. Anyway, there is nothing like implementing a more complex algorithm to test a language: can you implement this (http://blog.piccolboni.info/2011/04/looking-for-map-reduce-language.html) with hive and nothing else? If you can I will gladly concede that I had underestimated its power, and I think we&#39;ll learn a lot from the implementation.Antonio PiccolboniThanks riffraff, the first line didn&#39;t belong in there, not sure how that happened. Now it&#39;s as Klaas himself wrote it, if it doesn&#39;t work we need to ask him!riffraffI have the feeling you have some kind of typo in the python code: it&#39;s invalid syntax in at least three different ways :)Fatal ErrorI think something like this would workSELECT count(*), wordFROM SELECT explode(sentences(lower(contents))) as word  FROM docs) Agroup by wordAntonioUpdated based on comments by Michael Driscoll before this entry was syndicated on the dataspora blog. Thanks to both!" />
<meta property="og:description" content="On a quest for an elegant and effective map reduce language, I went through a number of options and put together some considerations. And the winner is …Update: since writing this post, I was approached by Revolution Analytics to write yet another map reduce library, this time for R, and it is, of course, my new favorite. Check it out!In a couple of blog entries from my personal blog I described some map-reduce algorithms for statistical and graph problems and sketched their implementation using pseudo-code. Pseudo-code has two problems: not everybody agrees on what a statement means and it doesn&#39;t run, so you can&#39;t test it or use it. Real programming languages on the other hand tend to obscure the logic of a program with unnecessary detail and have other issues that hinder readability, the reason why people resort to pseudo-code. But there is more to it than just aesthetics. Conciseness of code is related to programming abstractions, constructs that achieve higher generality and remove unnecessary detail; to reuse, whereby the same code is used in different contexts, reducing total program size; and even testing, that is concise programs can be tested more easily. In short, short is better. The elegance of less is hardly my own or a software engineering discovery. As Antoine de Saint-Exupery, French writer and aviator, so eloquently put it :Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.Unfortunately, in some circles, dull, predictable, repetitive code is considered simpler than short and to the point code, or at least tolerable. From java.util.Arrays:478     /*479      * The code for each of the seven primitive types is largely identical.480      * C&#39;est la vie.481      */In this case, repetition gets a free pass in exchange for efficiency. Very expressive languages tend to exact a higher toll on resources, and the different map-reduce environments we will look into are no exception.I will present for each language or library the implementation of a word count program, lifted from its documentation, since this has become sort of the &quot;Hello World&quot; for map reduce. I don&#39;t think such a simple program is the ultimate test of the quality of a language, so this is just to give a taste of the language. What I am most interested in is:Can I write reasonably concise, abstract programs in this language or library?Can I write the &quot;inside&quot; of map reduce, that is the code for the mapper and the reducer, as well as the &quot;outside&quot;, the logic that decides which map reduce jobs to run?Is it general? Can I write any map-reduce program, including programs that require multiple map-reduce jobs, including the case of a data dependent number and type of jobs?Java Hadoop This is the original, the real thing, the current performance champion and what &quot;real men&quot; write in. It is also the most mature of the different options. But take a look:public static class MapClass extends MapReduceBase public class WordCount {     public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {       private final static IntWritable one = new IntWritable(1);              private Text word = new Text();        public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         String line = value.toString();         StringTokenizer tokenizer = new StringTokenizer(line);         while (tokenizer.hasMoreTokens()) {           word.set(tokenizer.nextToken());           output.collect(word, one);         }       }     }      public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {       public void reduce(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         int sum = 0;         while (values.hasNext()) {           sum += values.next().get();         }         output.collect(key, new IntWritable(sum));       }     }      public static void main(String[] args) throws Exception {       JobConf conf = new JobConf(WordCount.class);       conf.setJobName(&quot;wordcount&quot;);        conf.setOutputKeyClass(Text.class);       conf.setOutputValueClass(IntWritable.class);        conf.setMapperClass(Map.class);       conf.setCombinerClass(Reduce.class);       conf.setReducerClass(Reduce.class);        conf.setInputFormat(TextInputFormat.class);       conf.setOutputFormat(TextOutputFormat.class);        conf.setInputPath(new Path(args[0]));       conf.setOutputPath(new Path(args[1]));        JobClient.runJob(conf);     } } 48 lines to write a word count program (and I stripped the import statements at the top out of mercy)! My favorite line is number 5, a line devoted to redefining the number one. This makes sense in a world where programmer productivity is measured by number of lines of code written or for a production job that runs on a 1,000 node cluster for 5 hours every night, in which case efficiency may trump other considerations. But for a blog, for discussing and enjoying code, anything remotely more interesting than a word count program would not fit the size of an entry but would have to be an attachment, as John Mount did with his painstaking Java/Hadoop implementation of logistic regression. I wonder how many people opened that tar file and read it through and through. Hadoop was started by Doug Cutting and is developed by a large community with a significant group employed at Yahoo.CascadingCascading is a Java library written on top of Hadoop. It enables programming in a dataflow style, with some primitives inspired by SQL (like GroupBy). But according to a person closely related to the project, &quot;it&#39;s still Java, it&#39;s still boilerplate code&quot;. My favorite line is number 18. Remarkably, it trims down the line count for the word count program to half as many as plain Hadoop. I don&#39;t have first hand experience with Cascading, but since there is no or little performance penalty compared to the real thing — depending on programmer skill, it could actually be better — it&#39;s worth a try for production work. Cascading is developed by Chris Wensel at Concurrent.Scheme sourceScheme = new TextLine( new Fields( &quot;line&quot; ) );Tap source = new Hfs( sourceScheme, inputPath );Scheme sinkScheme = new TextLine( new Fields( &quot;word&quot;, &quot;count&quot; ) );Tap sink = new Hfs( sinkScheme, outputPath, SinkMode.REPLACE );Pipe assembly = new Pipe( &quot;wordcount&quot; );String regex = &quot;(?&gt;!\\pL)(?=\\pL)[^ ]*(?&lt;=\\pL)(?!\\pL)&quot;;Function function = new RegexGenerator( new Fields( &quot;word&quot; ), regex );assembly = new Each( assembly, new Fields( &quot;line&quot; ), function );assembly = new GroupBy( assembly, new Fields( &quot;word&quot; ) );Aggregator count = new Count( new Fields( &quot;count&quot; ) );assembly = new Every( assembly, count );Properties properties = new Properties();FlowConnector.setApplicationJarClass( properties, Main.class );FlowConnector flowConnector = new FlowConnector( properties );Flow flow = flowConnector.connect( &quot;word-count&quot;, source, sink, assembly );flow.complete();Pipes — C++C++ fits into the Java environment not without some effort, which is encapsulated in a library called Pipes. The word count program looks more compact than in Java/Hadoop. I&#39;ve read opposite comments on the efficiency of Pipes/C++ vs Hadoop/Java and I suspect it may depend on the specific problem being tackled. Even if I used to be quite proficient in C++, I do not remember fondly the 8000 characters template-induced error messages and I don&#39;t think it is the type of language I would want to use to discuss algorithms or for prototyping. Pipes is developed as part of the Hadoop project.class WordCountMap: public HadoopPipes::Mapper {public:  WordCountMap(HadoopPipes::TaskContext&amp; context){}  void map(HadoopPipes::MapContext&amp; context) {    std::vector&lt;std::string&gt; words =      HadoopUtils::splitString(context.getInputValue(), &quot; &quot;);    for(unsigned int i=0; i &lt; words.size(); ++i) {      context.emit(words[i], &quot;1&quot;);    }  }};class WordCountReduce: public HadoopPipes::Reducer {public:  WordCountReduce(HadoopPipes::TaskContext&amp; context){}  void reduce(HadoopPipes::ReduceContext&amp; context) {    int sum = 0;    while (context.nextValue()) {      sum += HadoopUtils::toInt(context.getInputValue());    }    context.emit(context.getInputKey(), HadoopUtils::toString(sum));  }};int main(int argc, char *argv[]) {  return HadoopPipes::runTask(HadoopPipes::TemplateFactory&lt;WordCountMap,                              WordCountReduce&gt;());}HiveHive is a SQL-like language that is interpreted on top of Hadoop. It can also be combined with small programs written in a variety of languages, to make up for the fact that the language itself is not general purpose. For what it does, it is very concise and expressive, but outside that you need to supplement it with other languages. Case in point, the word count example where two additional scripts are left as an exercise for the reader. Hive started as part of the Hadoop project.FROM(MAP docs.contents USING &#39;tokenizer_script&#39; AS word, cntFROM docsCLUSTER BY word) map_outputREDUCE map_output.word, map_output.cnt USING &#39;count_script&#39; AS word, cnt;PigPig adds to the limitations of Hive the hubris of creating a brand new language, as if creating a new programming language were easy. As you can see, it is inspired by SQL to a degree. It is not a general purpose language as clearly explained here. It interfaces with any JVM based language for custom extensions.A = load &#39;/tmp/bible+shakes.nopunc&#39;;B = foreach A generate flatten(TOKENIZE((chararray)$0)) as word;C = filter B by word matches &#39;\\w+&#39;;D = group C by word;E = foreach D generate COUNT(C) as count, group as word;F = order E by count desc;store F into &#39;/tmp/wc&#39;;Pig development was started at Yahoo.RhipeRhipe is an R package to describe and execute map-reduce jobs. It is reasonably high level and satisfies all the criteria I listed above. It&#39;s not a speed daemon, because of R itself, there are some quirks in the API and it&#39;s still at an initial stage of development, but interesting. rhinit()m &lt;- expression({  y &lt;- strsplit(unlist(map.values),&quot; &quot;)  lapply(y,function(r) rhcollect(r,T))})r &lt;- expression(    pre={      count=0    },    reduce={      count &lt;- sum(as.numeric(unlist(reduce.values)),count)    },post={      rhcollect(reduce.key,count)    })z=rhmr(map=m,reduce=r,comb=T,inout=c(&quot;text&quot;,&quot;sequence&quot;),ifolder=&quot;/tmp/50mil&quot;,ofolder=&#39;/tmp/tof&#39;)rhex(z)Rhipe is developed by Saptarshi Guha at Mozilla.DumboDumbo is a Hadoop library for python, but also imposes a set of tools to run dumbo program. If you look at the word count program in Dumbo, below, it almost looks like pseudo-code! Finally! But there is a serious catch. There can only be a run statement per dumbo-powered program — I asked the author himself after seeing some outlandish looking errors. To coordinate two runs, for instance one that starts based on the output of the first, one has to run separate python programs and go through the unix shell. This is different from static composition of jobs, which is well supported, but not general enough for my purposes. Other options for python include MR Job and pydoop, but I haven&#39;t had time to look into these yet.def mapper(key,value):   for word in value.split(): yield word,1def reducer(key,values):   yield key,sum(values)if __name__ == &quot;__main__&quot;:   import dumbo   dumbo.run(mapper,reducer)Dumbo is developed by Klaas Bosteels at last.fm.CascalogBuilt on top of the already powerful cascading as a domain specific language within Clojure, Cascalog wins the word count conciseness contest with a one-liner. Indeed, word counting is simple enough that a line is all that it should take. But look at what a line:(?&lt;- (stdout) [?word ?count] (sentence ?s) (split ?s :&gt; ?word) (c/ count ?count))It probably looks familiar to anybody who&#39;s familiar with it. Conciseness can become terseness, but once some domain specific concepts have been grasped a terse program such as this might become perfectly clear. It was to me at some point. My misgivings here are more about the JVM-powered revival of LISP in the form of Clojure. LISP has been around some 50-odd years without taking off despite several attempts at its revival (Common LISP, Scheme, Arc and now Clojure). I suspect something is wrong with it, even if popularity is not an accurate gauge of language quality, as BASIC has long proved. Personally, I dislike LISP odd syntax, the widespread use of side effects in a functional language and the poor abstraction that lists represent over RAM, from a performance point of view — indeed LISP variants often add additional data structures, somehow negating the &quot;LIS&quot; part of the language. In the specific case of Clojure, the fact that a compiled language is compiled into an interpreted one, JVM bytecode, combining a slow dev cycle with suboptimal performance, makes me think Clojure users must be glutton for punishment.  Cascalog is  developed by Nathan Marz at Backtype.Final thoughtsAt the end of this by necessity incomplete and unscientific language and library comparison, there is a winner and there isn&#39;t. There isn&#39;t because language comparison is always multidimensional and subjective but also because the intended applications are very different. On the other hand, looking for a general purpose, moderately elegant, not necessarily most efficient, not necessarily mature language for exploration purposes, Rhipe seems to fit the bill pretty nicely. First, it is just a library, which means that one can continue to use the tools he&#39;s familiar with. I found it particularly useful to run map-reduce jobs in the interpreter, inspecting the inputs and outputs of each, an invaluable debugging help — but no, you can not step into a mapper or reducer, I use counters instead to trace what&#39;s going on in there. I also like that one can read and write sequence files with one call, to examine the output of previous jobs and decide what to do next. Additionally since R is a statistical language and Hadoop is the tool of choice for big data analytics, this seems like a natural fit. Personally, I am familiar with both, which helps, and I have used R, in combination with Hive or Hadoop, to do analytics in the past, but not at this level of integration. Since there is nothing like trying a more substantial example than word count to figure out a language pros and cons, stay tuned for a fairly complex example. After that is published, I plan to pose a friendly challenge to experts in the languages and libraries above or other Hadoop related languages and see what an implementation of the same algorithm would look like in their language of choice and learn something from the comparison. Maybe among my &quot;25 readers&quot; there is someone who will take it up.CommentsJeremyNot considering Hadoop Streaming seems like a pretty big omission.Antonio Piccolbonidieswaytoofast, that makes Erlang a good candidate for implementing Hadoop itself. In fact Disco (discoproject.org) is a Hadoop equivalent in Erlang. I am not aware of Hadoop libraries for Erlang.Brian, good point and add scrunch https://github.com/cloudera/crunch/tree/master/scrunch to the mix. This post is getting obsolete pretty quickly, as sign of the frantic activity around Hadoop.Brian SchliningScala? See https://github.com/NICTA/scoobival lines = fromTextFile(&quot;hdfs://in/...&quot;)  val counts = lines.flatMap(_.split(&quot; &quot;))                    .map(word =&gt; (word, 1))                    .groupByKey                    .combine(_+_)  persist(toTextFile(counts, &quot;hdfs://out/...&quot;))dieswaytoofastErrr, Erlang??? The semantics and the inbuilt parallelism would seem to fit the bill quite well, no?AnonymousI prefer ruby with streaming.  Personally, I don&#39;t see the need for any higher-level framework on top of it as it&#39;s already extremely easy to deal with STDIN/STDOUT on its own.Fatal ErrorI think the important thing about UDF&#39;s is what is the user excepted to write versus what is already available? From an end user perspective there is no difference between invoking SENTENCES and any other keyword in the hive syntax. Under the covers, it&#39;s all java anyway, but the point is to abstract people that want to be abstracted while still providing a powerful too.So, yes, I consider it part of the core languageAntonio PiccolboniThanks Fatal Error, I wasn&#39;t aware of the sentences UDF, nor I have written this Hive snippet that comes straight from the documentation. Since this UDF itself is written in a different language, not in Hive, it looks to me you are still supporting the point that you need other languages to integrate and extend Hive, unless you consider the UDF sentences part of the core language, which seems like a stretch to me. Anyway, there is nothing like implementing a more complex algorithm to test a language: can you implement this (http://blog.piccolboni.info/2011/04/looking-for-map-reduce-language.html) with hive and nothing else? If you can I will gladly concede that I had underestimated its power, and I think we&#39;ll learn a lot from the implementation.Antonio PiccolboniThanks riffraff, the first line didn&#39;t belong in there, not sure how that happened. Now it&#39;s as Klaas himself wrote it, if it doesn&#39;t work we need to ask him!riffraffI have the feeling you have some kind of typo in the python code: it&#39;s invalid syntax in at least three different ways :)Fatal ErrorI think something like this would workSELECT count(*), wordFROM SELECT explode(sentences(lower(contents))) as word  FROM docs) Agroup by wordAntonioUpdated based on comments by Michael Driscoll before this entry was syndicated on the dataspora blog. Thanks to both!" />
<link rel="canonical" href="http://piccolboni.info/2011/04/looking-for-map-reduce-language.html" />
<meta property="og:url" content="http://piccolboni.info/2011/04/looking-for-map-reduce-language.html" />
<meta property="og:site_name" content="Antonio Piccolboni" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-04-07T00:00:00-07:00" />
<link rel="next" href="http://piccolboni.info/2011/04/let-million-twitters-bloom.html" title="Let a million Twitters bloom" />
<link rel="prev" href="http://piccolboni.info/2010/11/find-odd-bag.html" title="Find the odd bag" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Looking for a map reduce language",
    "datePublished": "2011-04-07T00:00:00-07:00",
    "description": "On a quest for an elegant and effective map reduce language, I went through a number of options and put together some considerations. And the winner is …Update: since writing this post, I was approached by Revolution Analytics to write yet another map reduce library, this time for R, and it is, of course, my new favorite. Check it out!In a couple of blog entries from my personal blog I described some map-reduce algorithms for statistical and graph problems and sketched their implementation using pseudo-code. Pseudo-code has two problems: not everybody agrees on what a statement means and it doesn&#39;t run, so you can&#39;t test it or use it. Real programming languages on the other hand tend to obscure the logic of a program with unnecessary detail and have other issues that hinder readability, the reason why people resort to pseudo-code. But there is more to it than just aesthetics. Conciseness of code is related to programming abstractions, constructs that achieve higher generality and remove unnecessary detail; to reuse, whereby the same code is used in different contexts, reducing total program size; and even testing, that is concise programs can be tested more easily. In short, short is better. The elegance of less is hardly my own or a software engineering discovery. As Antoine de Saint-Exupery, French writer and aviator, so eloquently put it :Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.Unfortunately, in some circles, dull, predictable, repetitive code is considered simpler than short and to the point code, or at least tolerable. From java.util.Arrays:478     /*479      * The code for each of the seven primitive types is largely identical.480      * C&#39;est la vie.481      */In this case, repetition gets a free pass in exchange for efficiency. Very expressive languages tend to exact a higher toll on resources, and the different map-reduce environments we will look into are no exception.I will present for each language or library the implementation of a word count program, lifted from its documentation, since this has become sort of the &quot;Hello World&quot; for map reduce. I don&#39;t think such a simple program is the ultimate test of the quality of a language, so this is just to give a taste of the language. What I am most interested in is:Can I write reasonably concise, abstract programs in this language or library?Can I write the &quot;inside&quot; of map reduce, that is the code for the mapper and the reducer, as well as the &quot;outside&quot;, the logic that decides which map reduce jobs to run?Is it general? Can I write any map-reduce program, including programs that require multiple map-reduce jobs, including the case of a data dependent number and type of jobs?Java Hadoop This is the original, the real thing, the current performance champion and what &quot;real men&quot; write in. It is also the most mature of the different options. But take a look:public static class MapClass extends MapReduceBase public class WordCount {     public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {       private final static IntWritable one = new IntWritable(1);              private Text word = new Text();        public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         String line = value.toString();         StringTokenizer tokenizer = new StringTokenizer(line);         while (tokenizer.hasMoreTokens()) {           word.set(tokenizer.nextToken());           output.collect(word, one);         }       }     }      public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {       public void reduce(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {         int sum = 0;         while (values.hasNext()) {           sum += values.next().get();         }         output.collect(key, new IntWritable(sum));       }     }      public static void main(String[] args) throws Exception {       JobConf conf = new JobConf(WordCount.class);       conf.setJobName(&quot;wordcount&quot;);        conf.setOutputKeyClass(Text.class);       conf.setOutputValueClass(IntWritable.class);        conf.setMapperClass(Map.class);       conf.setCombinerClass(Reduce.class);       conf.setReducerClass(Reduce.class);        conf.setInputFormat(TextInputFormat.class);       conf.setOutputFormat(TextOutputFormat.class);        conf.setInputPath(new Path(args[0]));       conf.setOutputPath(new Path(args[1]));        JobClient.runJob(conf);     } } 48 lines to write a word count program (and I stripped the import statements at the top out of mercy)! My favorite line is number 5, a line devoted to redefining the number one. This makes sense in a world where programmer productivity is measured by number of lines of code written or for a production job that runs on a 1,000 node cluster for 5 hours every night, in which case efficiency may trump other considerations. But for a blog, for discussing and enjoying code, anything remotely more interesting than a word count program would not fit the size of an entry but would have to be an attachment, as John Mount did with his painstaking Java/Hadoop implementation of logistic regression. I wonder how many people opened that tar file and read it through and through. Hadoop was started by Doug Cutting and is developed by a large community with a significant group employed at Yahoo.CascadingCascading is a Java library written on top of Hadoop. It enables programming in a dataflow style, with some primitives inspired by SQL (like GroupBy). But according to a person closely related to the project, &quot;it&#39;s still Java, it&#39;s still boilerplate code&quot;. My favorite line is number 18. Remarkably, it trims down the line count for the word count program to half as many as plain Hadoop. I don&#39;t have first hand experience with Cascading, but since there is no or little performance penalty compared to the real thing — depending on programmer skill, it could actually be better — it&#39;s worth a try for production work. Cascading is developed by Chris Wensel at Concurrent.Scheme sourceScheme = new TextLine( new Fields( &quot;line&quot; ) );Tap source = new Hfs( sourceScheme, inputPath );Scheme sinkScheme = new TextLine( new Fields( &quot;word&quot;, &quot;count&quot; ) );Tap sink = new Hfs( sinkScheme, outputPath, SinkMode.REPLACE );Pipe assembly = new Pipe( &quot;wordcount&quot; );String regex = &quot;(?&gt;!\\\\pL)(?=\\\\pL)[^ ]*(?&lt;=\\\\pL)(?!\\\\pL)&quot;;Function function = new RegexGenerator( new Fields( &quot;word&quot; ), regex );assembly = new Each( assembly, new Fields( &quot;line&quot; ), function );assembly = new GroupBy( assembly, new Fields( &quot;word&quot; ) );Aggregator count = new Count( new Fields( &quot;count&quot; ) );assembly = new Every( assembly, count );Properties properties = new Properties();FlowConnector.setApplicationJarClass( properties, Main.class );FlowConnector flowConnector = new FlowConnector( properties );Flow flow = flowConnector.connect( &quot;word-count&quot;, source, sink, assembly );flow.complete();Pipes — C++C++ fits into the Java environment not without some effort, which is encapsulated in a library called Pipes. The word count program looks more compact than in Java/Hadoop. I&#39;ve read opposite comments on the efficiency of Pipes/C++ vs Hadoop/Java and I suspect it may depend on the specific problem being tackled. Even if I used to be quite proficient in C++, I do not remember fondly the 8000 characters template-induced error messages and I don&#39;t think it is the type of language I would want to use to discuss algorithms or for prototyping. Pipes is developed as part of the Hadoop project.class WordCountMap: public HadoopPipes::Mapper {public:  WordCountMap(HadoopPipes::TaskContext&amp; context){}  void map(HadoopPipes::MapContext&amp; context) {    std::vector&lt;std::string&gt; words =      HadoopUtils::splitString(context.getInputValue(), &quot; &quot;);    for(unsigned int i=0; i &lt; words.size(); ++i) {      context.emit(words[i], &quot;1&quot;);    }  }};class WordCountReduce: public HadoopPipes::Reducer {public:  WordCountReduce(HadoopPipes::TaskContext&amp; context){}  void reduce(HadoopPipes::ReduceContext&amp; context) {    int sum = 0;    while (context.nextValue()) {      sum += HadoopUtils::toInt(context.getInputValue());    }    context.emit(context.getInputKey(), HadoopUtils::toString(sum));  }};int main(int argc, char *argv[]) {  return HadoopPipes::runTask(HadoopPipes::TemplateFactory&lt;WordCountMap,                              WordCountReduce&gt;());}HiveHive is a SQL-like language that is interpreted on top of Hadoop. It can also be combined with small programs written in a variety of languages, to make up for the fact that the language itself is not general purpose. For what it does, it is very concise and expressive, but outside that you need to supplement it with other languages. Case in point, the word count example where two additional scripts are left as an exercise for the reader. Hive started as part of the Hadoop project.FROM(MAP docs.contents USING &#39;tokenizer_script&#39; AS word, cntFROM docsCLUSTER BY word) map_outputREDUCE map_output.word, map_output.cnt USING &#39;count_script&#39; AS word, cnt;PigPig adds to the limitations of Hive the hubris of creating a brand new language, as if creating a new programming language were easy. As you can see, it is inspired by SQL to a degree. It is not a general purpose language as clearly explained here. It interfaces with any JVM based language for custom extensions.A = load &#39;/tmp/bible+shakes.nopunc&#39;;B = foreach A generate flatten(TOKENIZE((chararray)$0)) as word;C = filter B by word matches &#39;\\\\w+&#39;;D = group C by word;E = foreach D generate COUNT(C) as count, group as word;F = order E by count desc;store F into &#39;/tmp/wc&#39;;Pig development was started at Yahoo.RhipeRhipe is an R package to describe and execute map-reduce jobs. It is reasonably high level and satisfies all the criteria I listed above. It&#39;s not a speed daemon, because of R itself, there are some quirks in the API and it&#39;s still at an initial stage of development, but interesting. rhinit()m &lt;- expression({  y &lt;- strsplit(unlist(map.values),&quot; &quot;)  lapply(y,function(r) rhcollect(r,T))})r &lt;- expression(    pre={      count=0    },    reduce={      count &lt;- sum(as.numeric(unlist(reduce.values)),count)    },post={      rhcollect(reduce.key,count)    })z=rhmr(map=m,reduce=r,comb=T,inout=c(&quot;text&quot;,&quot;sequence&quot;),ifolder=&quot;/tmp/50mil&quot;,ofolder=&#39;/tmp/tof&#39;)rhex(z)Rhipe is developed by Saptarshi Guha at Mozilla.DumboDumbo is a Hadoop library for python, but also imposes a set of tools to run dumbo program. If you look at the word count program in Dumbo, below, it almost looks like pseudo-code! Finally! But there is a serious catch. There can only be a run statement per dumbo-powered program — I asked the author himself after seeing some outlandish looking errors. To coordinate two runs, for instance one that starts based on the output of the first, one has to run separate python programs and go through the unix shell. This is different from static composition of jobs, which is well supported, but not general enough for my purposes. Other options for python include MR Job and pydoop, but I haven&#39;t had time to look into these yet.def mapper(key,value):   for word in value.split(): yield word,1def reducer(key,values):   yield key,sum(values)if __name__ == &quot;__main__&quot;:   import dumbo   dumbo.run(mapper,reducer)Dumbo is developed by Klaas Bosteels at last.fm.CascalogBuilt on top of the already powerful cascading as a domain specific language within Clojure, Cascalog wins the word count conciseness contest with a one-liner. Indeed, word counting is simple enough that a line is all that it should take. But look at what a line:(?&lt;- (stdout) [?word ?count] (sentence ?s) (split ?s :&gt; ?word) (c/ count ?count))It probably looks familiar to anybody who&#39;s familiar with it. Conciseness can become terseness, but once some domain specific concepts have been grasped a terse program such as this might become perfectly clear. It was to me at some point. My misgivings here are more about the JVM-powered revival of LISP in the form of Clojure. LISP has been around some 50-odd years without taking off despite several attempts at its revival (Common LISP, Scheme, Arc and now Clojure). I suspect something is wrong with it, even if popularity is not an accurate gauge of language quality, as BASIC has long proved. Personally, I dislike LISP odd syntax, the widespread use of side effects in a functional language and the poor abstraction that lists represent over RAM, from a performance point of view — indeed LISP variants often add additional data structures, somehow negating the &quot;LIS&quot; part of the language. In the specific case of Clojure, the fact that a compiled language is compiled into an interpreted one, JVM bytecode, combining a slow dev cycle with suboptimal performance, makes me think Clojure users must be glutton for punishment.  Cascalog is  developed by Nathan Marz at Backtype.Final thoughtsAt the end of this by necessity incomplete and unscientific language and library comparison, there is a winner and there isn&#39;t. There isn&#39;t because language comparison is always multidimensional and subjective but also because the intended applications are very different. On the other hand, looking for a general purpose, moderately elegant, not necessarily most efficient, not necessarily mature language for exploration purposes, Rhipe seems to fit the bill pretty nicely. First, it is just a library, which means that one can continue to use the tools he&#39;s familiar with. I found it particularly useful to run map-reduce jobs in the interpreter, inspecting the inputs and outputs of each, an invaluable debugging help — but no, you can not step into a mapper or reducer, I use counters instead to trace what&#39;s going on in there. I also like that one can read and write sequence files with one call, to examine the output of previous jobs and decide what to do next. Additionally since R is a statistical language and Hadoop is the tool of choice for big data analytics, this seems like a natural fit. Personally, I am familiar with both, which helps, and I have used R, in combination with Hive or Hadoop, to do analytics in the past, but not at this level of integration. Since there is nothing like trying a more substantial example than word count to figure out a language pros and cons, stay tuned for a fairly complex example. After that is published, I plan to pose a friendly challenge to experts in the languages and libraries above or other Hadoop related languages and see what an implementation of the same algorithm would look like in their language of choice and learn something from the comparison. Maybe among my &quot;25 readers&quot; there is someone who will take it up.CommentsJeremyNot considering Hadoop Streaming seems like a pretty big omission.Antonio Piccolbonidieswaytoofast, that makes Erlang a good candidate for implementing Hadoop itself. In fact Disco (discoproject.org) is a Hadoop equivalent in Erlang. I am not aware of Hadoop libraries for Erlang.Brian, good point and add scrunch https://github.com/cloudera/crunch/tree/master/scrunch to the mix. This post is getting obsolete pretty quickly, as sign of the frantic activity around Hadoop.Brian SchliningScala? See https://github.com/NICTA/scoobival lines = fromTextFile(&quot;hdfs://in/...&quot;)  val counts = lines.flatMap(_.split(&quot; &quot;))                    .map(word =&gt; (word, 1))                    .groupByKey                    .combine(_+_)  persist(toTextFile(counts, &quot;hdfs://out/...&quot;))dieswaytoofastErrr, Erlang??? The semantics and the inbuilt parallelism would seem to fit the bill quite well, no?AnonymousI prefer ruby with streaming.  Personally, I don&#39;t see the need for any higher-level framework on top of it as it&#39;s already extremely easy to deal with STDIN/STDOUT on its own.Fatal ErrorI think the important thing about UDF&#39;s is what is the user excepted to write versus what is already available? From an end user perspective there is no difference between invoking SENTENCES and any other keyword in the hive syntax. Under the covers, it&#39;s all java anyway, but the point is to abstract people that want to be abstracted while still providing a powerful too.So, yes, I consider it part of the core languageAntonio PiccolboniThanks Fatal Error, I wasn&#39;t aware of the sentences UDF, nor I have written this Hive snippet that comes straight from the documentation. Since this UDF itself is written in a different language, not in Hive, it looks to me you are still supporting the point that you need other languages to integrate and extend Hive, unless you consider the UDF sentences part of the core language, which seems like a stretch to me. Anyway, there is nothing like implementing a more complex algorithm to test a language: can you implement this (http://blog.piccolboni.info/2011/04/looking-for-map-reduce-language.html) with hive and nothing else? If you can I will gladly concede that I had underestimated its power, and I think we&#39;ll learn a lot from the implementation.Antonio PiccolboniThanks riffraff, the first line didn&#39;t belong in there, not sure how that happened. Now it&#39;s as Klaas himself wrote it, if it doesn&#39;t work we need to ask him!riffraffI have the feeling you have some kind of typo in the python code: it&#39;s invalid syntax in at least three different ways :)Fatal ErrorI think something like this would workSELECT count(*), wordFROM SELECT explode(sentences(lower(contents))) as word  FROM docs) Agroup by wordAntonioUpdated based on comments by Michael Driscoll before this entry was syndicated on the dataspora blog. Thanks to both!",
    "url": "http://piccolboni.info/2011/04/looking-for-map-reduce-language.html"
  }
</script>
<!-- End Jekyll SEO tag -->
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Antonio Piccolboni</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about">About me</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/contact">Contact</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/projects">Projects</a>
          
        
          
        
          
          <a class="page-link" href="/speaking">Speaking</a>
          
        
          
          <a class="page-link" href="/writing">Writing</a>
          
        
        <a class="page-link" href="https://feedburner.google.com/fb/a/mailverify?uri=piccolboni/qdqo&amp;loc=en_US">Subscribe</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Looking for a map reduce language</h1>
    <p class="post-meta">Apr 7, 2011</p>
  </header>

  <article class="post-content">
    <div class='post'>
On a quest for an elegant and effective map reduce language, I went through a number of options and put together some considerations. And the winner is …<br /><!--more--><a name='more'></a><br />Update: since writing this post, I was approached by Revolution Analytics to write yet another map reduce library, this time for R, and it is, of course, my new favorite. <a href="https://github.com/RevolutionAnalytics/RHadoop/wiki/rmr">Check it out</a>!<br /><br />In a couple of blog entries from my personal blog I described some map-reduce algorithms for <a href="http://blog.piccolboni.info/2010/07/algorithm-for-sample-quantiles-in-map.html">statistical</a> and <a href="http://blog.piccolboni.info/2010/07/map-reduce-algorithm-for-connected.html">graph</a> problems and sketched their implementation using pseudo-code. Pseudo-code has two problems: not everybody agrees on what a statement means and it doesn't run, so you can't test it or use it. Real programming languages on the other hand tend to obscure the logic of a program with unnecessary detail and have other issues that hinder readability, the reason why people resort to pseudo-code. But there is more to it than just aesthetics. Conciseness of code is related to programming abstractions, constructs that achieve higher generality and remove unnecessary detail; to reuse, whereby the same code is used in different contexts, reducing total program size; and even <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.567">testing</a>, that is concise programs can be tested more easily. In short, short is better. The elegance of less is hardly my own or a software engineering discovery. As Antoine de Saint-Exupery, French writer and aviator, so eloquently put it :<br /><blockquote><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.</div></blockquote>Unfortunately, in some circles, dull, predictable, repetitive code is considered simpler than short and to the point code, or at least tolerable. From java.util.Arrays:<br /><blockquote>478     /*<br />479      * The code for each of the seven primitive types is largely identical.<br />480      * C'est la vie.<br />481      */</blockquote>In this case, repetition gets a free pass in exchange for efficiency. Very expressive languages tend to exact a higher toll on resources, and the different map-reduce environments we will look into are no exception.<br />I will present for each language or library the implementation of a word count program, lifted from its documentation, since this has become sort of the "Hello World" for map reduce. I don't think such a simple program is the ultimate test of the quality of a language, so this is just to give a taste of the language. What I am most interested in is:<br /><ul><li>Can I write reasonably concise, abstract programs in this language or library?</li><li>Can I write the "inside" of map reduce, that is the code for the mapper and the reducer, as well as the "outside", the logic that decides which map reduce jobs to run?</li><li>Is it general? Can I write any map-reduce program, including programs that require multiple map-reduce jobs, including the case of a data dependent number and type of jobs?</li></ul><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Java Hadoop </span><br />This is the original, the real thing, the current performance champion and what "real men" write in. It is also the most mature of the different options. But take a look:<br /><br /><pre class="brush: java">public static class MapClass extends MapReduceBase<br /> public class WordCount {<br /><br />     public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {<br />       private final static IntWritable one = new IntWritable(1);<br />              private Text word = new Text();<br /> <br />       public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {<br />         String line = value.toString();<br />         StringTokenizer tokenizer = new StringTokenizer(line);<br />         while (tokenizer.hasMoreTokens()) {<br />           word.set(tokenizer.nextToken());<br />           output.collect(word, one);<br />         }<br />       }<br />     }<br /> <br />     public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {<br />       public void reduce(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {<br />         int sum = 0;<br />         while (values.hasNext()) {<br />           sum += values.next().get();<br />         }<br />         output.collect(key, new IntWritable(sum));<br />       }<br />     }<br /> <br />     public static void main(String[] args) throws Exception {<br />       JobConf conf = new JobConf(WordCount.class);<br />       conf.setJobName("wordcount");<br /> <br />       conf.setOutputKeyClass(Text.class);<br />       conf.setOutputValueClass(IntWritable.class);<br /> <br />       conf.setMapperClass(Map.class);<br />       conf.setCombinerClass(Reduce.class);<br />       conf.setReducerClass(Reduce.class);<br /> <br />       conf.setInputFormat(TextInputFormat.class);<br />       conf.setOutputFormat(TextOutputFormat.class);<br /> <br />       conf.setInputPath(new Path(args[0]));<br />       conf.setOutputPath(new Path(args[1]));<br /> <br />       JobClient.runJob(conf);<br />     }<br /> }<br /> <br /></pre>48 lines to write a word count program (and I stripped the import statements at the top out of mercy)! My favorite line is number 5, a line devoted to redefining the number one. This makes sense in a world where programmer productivity is measured by number of lines of code written or for a production job that runs on a 1,000 node cluster for 5 hours every night, in which case efficiency may trump other considerations. But for a blog, for discussing and enjoying code, anything remotely more interesting than a word count program would not fit the size of an entry but would have to be an attachment, as John Mount did with his painstaking <a href="http://www.win-vector.com/blog/2010/12/large-data-logistic-regression-with-example-hadoop-code/">Java/Hadoop implementation of logistic regression</a>. I wonder how many people opened that tar file and read it through and through. <br />Hadoop was started by Doug Cutting and is developed by a large community with a significant group employed at Yahoo.<br /><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Cascading</span><br />Cascading is a Java library written on top of Hadoop. It enables programming in a dataflow style, with some primitives inspired by SQL (like GroupBy). But according to a person closely related to the project, "it's still Java, it's still boilerplate code". My favorite line is number 18. Remarkably, it trims down the line count for the word count program to half as many as plain Hadoop. I don't have first hand experience with Cascading, but since there is no or little performance penalty compared to the real thing — depending on programmer skill, it could actually be better — it's worth a try for production work. <br />Cascading is developed by Chris Wensel at Concurrent.<br /><br /><pre class="brush: java">Scheme sourceScheme = new TextLine( new Fields( "line" ) );<br />Tap source = new Hfs( sourceScheme, inputPath );<br /><br />Scheme sinkScheme = new TextLine( new Fields( "word", "count" ) );<br />Tap sink = new Hfs( sinkScheme, outputPath, SinkMode.REPLACE );<br /><br />Pipe assembly = new Pipe( "wordcount" );<br /><br />String regex = "(?&gt;!\\pL)(?=\\pL)[^ ]*(?&lt;=\\pL)(?!\\pL)";<br />Function function = new RegexGenerator( new Fields( "word" ), regex );<br />assembly = new Each( assembly, new Fields( "line" ), function );<br /><br />assembly = new GroupBy( assembly, new Fields( "word" ) );<br /><br />Aggregator count = new Count( new Fields( "count" ) );<br />assembly = new Every( assembly, count );<br /><br />Properties properties = new Properties();<br />FlowConnector.setApplicationJarClass( properties, Main.class );<br /><br />FlowConnector flowConnector = new FlowConnector( properties );<br />Flow flow = flowConnector.connect( "word-count", source, sink, assembly );<br /><br />flow.complete();<br /></pre><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Pipes — C++</span><br />C++ fits into the Java environment not without some effort, which is encapsulated in a library called Pipes. The word count program looks more compact than in Java/Hadoop. I've read opposite comments on the efficiency of Pipes/C++ vs Hadoop/Java and I suspect it may depend on the specific problem being tackled. Even if I used to be quite proficient in C++, I do not remember fondly the 8000 characters template-induced error messages and I don't think it is the type of language I would want to use to discuss algorithms or for prototyping. <br />Pipes is developed as part of the Hadoop project.<br /><br /><pre class="brush: cpp">class WordCountMap: public HadoopPipes::Mapper {<br />public:<br />  WordCountMap(HadoopPipes::TaskContext&amp; context){}<br />  void map(HadoopPipes::MapContext&amp; context) {<br />    std::vector&lt;std::string&gt; words =<br />      HadoopUtils::splitString(context.getInputValue(), " ");<br />    for(unsigned int i=0; i &lt; words.size(); ++i) {<br />      context.emit(words[i], "1");<br />    }<br />  }<br />};<br /><br />class WordCountReduce: public HadoopPipes::Reducer {<br />public:<br />  WordCountReduce(HadoopPipes::TaskContext&amp; context){}<br />  void reduce(HadoopPipes::ReduceContext&amp; context) {<br />    int sum = 0;<br />    while (context.nextValue()) {<br />      sum += HadoopUtils::toInt(context.getInputValue());<br />    }<br />    context.emit(context.getInputKey(), HadoopUtils::toString(sum));<br />  }<br />};<br /><br />int main(int argc, char *argv[]) {<br />  return HadoopPipes::runTask(HadoopPipes::TemplateFactory&lt;WordCountMap,<br />                              WordCountReduce&gt;());<br />}<br /></pre><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Hive</span><br />Hive is a SQL-like language that is interpreted on top of Hadoop. It can also be combined with small programs written in a variety of languages, to make up for the fact that the language itself is not general purpose. For what it does, it is very concise and expressive, but outside that you need to supplement it with other languages. Case in point, the word count example where two additional scripts are left as an exercise for the reader. <br />Hive started as part of the Hadoop project.<br /><br /><pre>FROM<br />(MAP docs.contents USING 'tokenizer_script' AS word, cnt<br />FROM docs<br />CLUSTER BY word) map_output<br /><br />REDUCE map_output.word, map_output.cnt USING 'count_script' AS word, cnt;<br /></pre><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Pig</span><br />Pig adds to the limitations of Hive the hubris of creating a brand new language, as if creating a new programming language were easy. As you can see, it is inspired by SQL to a degree. It is not a general purpose language as clearly explained <a href="http://wiki.apache.org/pig/TuringCompletePig">here</a>. It interfaces with any JVM based language for custom extensions.<br /><br /><br /><pre>A = load '/tmp/bible+shakes.nopunc';<br />B = foreach A generate flatten(TOKENIZE((chararray)$0)) as word;<br />C = filter B by word matches '\\w+';<br />D = group C by word;<br />E = foreach D generate COUNT(C) as count, group as word;<br />F = order E by count desc;<br />store F into '/tmp/wc';<br /></pre>Pig development was started at Yahoo.<br /><br /><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Rhipe</span><br />Rhipe is an R package to describe and execute map-reduce jobs. It is reasonably high level and satisfies all the criteria I listed above. It's not a speed daemon, because of R itself, there are some quirks in the API and it's still at an initial stage of development, but interesting. <br /><br /><br /><pre>rhinit()<br />m &lt;- expression({<br />  y &lt;- strsplit(unlist(map.values)," ")<br />  lapply(y,function(r) rhcollect(r,T))<br />})<br />r &lt;- expression(<br />    pre={<br />      count=0<br />    },<br />    reduce={<br />      count &lt;- sum(as.numeric(unlist(reduce.values)),count)<br />    },post={<br />      rhcollect(reduce.key,count)<br />    })<br />z=rhmr(map=m,reduce=r,comb=T,inout=c("text","sequence"),ifolder="/tmp/50mil",ofolder='/tmp/tof')<br />rhex(z)<br /></pre>Rhipe is developed by Saptarshi Guha at Mozilla.<br /><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Dumbo</span><br />Dumbo is a Hadoop library for python, but also imposes a set of tools to run dumbo program. If you look at the word count program in Dumbo, below, it almost looks like pseudo-code! Finally! But there is a serious catch. There can only be a run statement per dumbo-powered program — I <a href="https://groups.google.com/d/msg/dumbo-user/9FFGeFAZqQc/N3uuo-S-61YJ">asked the author himself</a> after seeing some outlandish looking errors. To coordinate two runs, for instance one that starts based on the output of the first, one has to run separate python programs and go through the unix shell. This is different from static composition of jobs, which is well supported, but not general enough for my purposes. Other options for python include MR Job and pydoop, but I haven't had time to look into these yet.<br /><br /><pre class="brush: python">def mapper(key,value):<br />   for word in value.split(): yield word,1<br />def reducer(key,values):<br />   yield key,sum(values)<br />if __name__ == "__main__":<br />   import dumbo<br />   dumbo.run(mapper,reducer)<br /></pre>Dumbo is developed by Klaas Bosteels at last.fm.<br /><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Cascalog</span><br />Built on top of the already powerful cascading as a domain specific language within Clojure, Cascalog wins the word count conciseness contest with a one-liner. Indeed, word counting is simple enough that a line is all that it should take. But look at what a line:<br /><br /><pre>(?&lt;- (stdout) [?word ?count] (sentence ?s) (split ?s :&gt; ?word) (c/ count ?count))</pre>It probably looks familiar to anybody who's familiar with it. Conciseness can become terseness, but once some domain specific concepts have been grasped a terse program such as this might become perfectly clear. It was to me at some point. My misgivings here are more about the JVM-powered revival of LISP in the form of Clojure. LISP has been around some 50-odd years without taking off despite several attempts at its revival (Common LISP, Scheme, Arc and now Clojure). I suspect something is wrong with it, even if popularity is not an accurate gauge of language quality, as BASIC has long proved. Personally, I dislike LISP odd syntax, the widespread use of side effects in a functional language and the poor abstraction that lists represent over RAM, from a performance point of view — indeed LISP variants often add additional data structures, somehow negating the "LIS" part of the language. In the specific case of Clojure, the fact that a compiled language is compiled into an interpreted one, JVM bytecode, combining a slow dev cycle with suboptimal performance, makes me think Clojure users must be glutton for punishment.  <br />Cascalog is  developed by Nathan Marz at Backtype.<br /><span class="Apple-style-span" style="font-family: Arial, Helvetica, sans-serif; font-size: large;">Final thoughts</span><br />At the end of this by necessity incomplete and unscientific language and library comparison, there is a winner and there isn't. There isn't because language comparison is always multidimensional and subjective but also because the intended applications are very different. On the other hand, looking for a general purpose, moderately elegant, not necessarily most efficient, not necessarily mature language for exploration purposes, Rhipe seems to fit the bill pretty nicely. First, it is just a library, which means that one can continue to use the tools he's familiar with. I found it particularly useful to run map-reduce jobs in the interpreter, inspecting the inputs and outputs of each, an invaluable debugging help — but no, you can not step into a mapper or reducer, I use counters instead to trace what's going on in there. I also like that one can read and write sequence files with one call, to examine the output of previous jobs and decide what to do next. Additionally since R is a statistical language and Hadoop is the tool of choice for big data analytics, this seems like a natural fit. Personally, I am familiar with both, which helps, and I have used R, in combination with Hive or Hadoop, to do analytics in the past, but not at this level of integration. Since there is nothing like trying a more substantial example than word count to figure out a language pros and cons, stay tuned for a fairly complex <a href="http://blog.piccolboni.info/2011/04/map-reduce-algorithm-for-connected.html">example</a>. After that is published, I plan to pose a friendly challenge to experts in the languages and libraries above or other Hadoop related languages and see what an implementation of the same algorithm would look like in their language of choice and learn something from the comparison. Maybe among my "25 readers" there is someone who will take it up.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Jeremy</div>
<div class='content'>
Not considering Hadoop Streaming seems like a pretty big omission.</div>
</div>
<div class='comment'>
<div class='author'>Antonio Piccolboni</div>
<div class='content'>
dieswaytoofast, that makes Erlang a good candidate for implementing Hadoop itself. In fact Disco (discoproject.org) is a Hadoop equivalent in Erlang. I am not aware of Hadoop libraries for Erlang.<br /><br />Brian, good point and add scrunch https://github.com/cloudera/crunch/tree/master/scrunch to the mix. This post is getting obsolete pretty quickly, as sign of the frantic activity around Hadoop.</div>
</div>
<div class='comment'>
<div class='author'>Brian Schlining</div>
<div class='content'>
Scala? See https://github.com/NICTA/scoobi<br /><br />val lines = fromTextFile(&quot;hdfs://in/...&quot;)<br /><br />  val counts = lines.flatMap(_.split(&quot; &quot;))<br />                    .map(word =&gt; (word, 1))<br />                    .groupByKey<br />                    .combine(_+_)<br /><br />  persist(toTextFile(counts, &quot;hdfs://out/...&quot;))</div>
</div>
<div class='comment'>
<div class='author'>dieswaytoofast</div>
<div class='content'>
Errr, Erlang??? The semantics and the inbuilt parallelism would seem to fit the bill quite well, no?</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I prefer ruby with streaming.  Personally, I don&#39;t see the need for any higher-level framework on top of it as it&#39;s already extremely easy to deal with STDIN/STDOUT on its own.</div>
</div>
<div class='comment'>
<div class='author'>Fatal Error</div>
<div class='content'>
I think the important thing about UDF&#39;s is what is the user excepted to write versus what is already available? <br /><br />From an end user perspective there is no difference between invoking SENTENCES and any other keyword in the hive syntax. Under the covers, it&#39;s all java anyway, but the point is to abstract people that want to be abstracted while still providing a powerful too.<br /><br />So, yes, I consider it part of the core language</div>
</div>
<div class='comment'>
<div class='author'>Antonio Piccolboni</div>
<div class='content'>
Thanks Fatal Error, I wasn&#39;t aware of the sentences UDF, nor I have written this Hive snippet that comes straight from the documentation. Since this UDF itself is written in a different language, not in Hive, it looks to me you are still supporting the point that you need other languages to integrate and extend Hive, unless you consider the UDF sentences part of the core language, which seems like a stretch to me. Anyway, there is nothing like implementing a more complex algorithm to test a language: can you implement this (http://blog.piccolboni.info/2011/04/looking-for-map-reduce-language.html) with hive and nothing else? If you can I will gladly concede that I had underestimated its power, and I think we&#39;ll learn a lot from the implementation.</div>
</div>
<div class='comment'>
<div class='author'>Antonio Piccolboni</div>
<div class='content'>
Thanks riffraff, the first line didn&#39;t belong in there, not sure how that happened. Now it&#39;s as Klaas himself wrote it, if it doesn&#39;t work we need to ask him!</div>
</div>
<div class='comment'>
<div class='author'>riffraff</div>
<div class='content'>
I have the feeling you have some kind of typo in the python code: it&#39;s invalid syntax in at least three different ways :)</div>
</div>
<div class='comment'>
<div class='author'>Fatal Error</div>
<div class='content'>
I think something like this would work<br /><br />SELECT count(*), word<br />FROM<br /> SELECT explode(sentences(lower(contents))) as word<br />  FROM docs) A<br />group by word</div>
</div>
<div class='comment'>
<div class='author'>Antonio</div>
<div class='content'>
Updated based on comments by Michael Driscoll before this entry was syndicated on the dataspora blog. Thanks to both!</div>
</div>
</div>

  </article>

  <div class="SendComment">
    <a href="mailto:antonio@piccolboni.info?subject=Looking for a map reduce language&body=http://piccolboni.info/2011/04/looking-for-map-reduce-language.html" target="_top">Email the author</a> or <a href="http://via.hypothes.is/http://piccolboni.info//2011/04/looking-for-map-reduce-language.html">annotate with hypothes.is</a>
  </div>
  <div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */

var disqus_config = function () {
    this.page.url = "http://piccolboni.info//2011/04/looking-for-map-reduce-language.html";
    this.page.identifier = "/2011/04/looking-for-map-reduce-language";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//piccolbo.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>

      </div>
    </div>
    <footer class="site-footer">

  <div class="wrapper">

    <div class="PageNavigation">
      
        <a class="prev" href="/2010/11/find-odd-bag.html">&laquo;    Find the odd bag</a>
      
      
        <a class="next" href="/2011/04/let-million-twitters-bloom.html">Let a million Twitters bloom &raquo;</a>
      
    </div>

  </div>

</footer>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-7018175-5', 'piccolboni.info');
  ga('send', 'pageview');

</script>

  </body>

</html>
