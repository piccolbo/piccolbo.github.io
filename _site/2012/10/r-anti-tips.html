<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>R anti-tips </title>
  <meta name="description" content="Not all R tips are equally good. Let's set the record straight. Anti-tip #1: For loops are slower than functions in the apply familyWhy should that be the ca...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://piccolboni.info/2012/10/r-anti-tips.html">
  <link rel="alternate" type="application/rss+xml" title="Antonio Piccolboni" href="http://piccolboni.info/atom.xml" />
  <link rel="shortcut icon" type="image/png" href="gravatar32.png?v=3">
  <script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
  </script>
  <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>R anti-tips  - Antonio Piccolboni</title>
<meta property="og:title" content="R anti-tips" />
<meta name="description" content="Not all R tips are equally good. Let&#39;s set the record straight. Anti-tip #1: For loops are slower than functions in the apply familyWhy should that be the case? Let&#39;s see what the R interpreter has to say about it. Let&#39;s get some numbers to chew on first:  z = rnorm(10^6)For loop first: &gt; system.time({x = 0; for(y in z) x = x + y})user &nbsp;system elapsed0.521 &nbsp; 0.004 &nbsp; 0.526To avoid the explicit loop a good match here is the Reduce function, which may be not exactly in the apply family, but it&#39;s faster than several attempts I made using those functions.      &gt; system.time({x = Reduce(&#39;+&#39;, z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.461 &nbsp; 0.030 &nbsp; 0.491Faster, but not by much.      The true tip: use C.      &gt; system.time({x = sum(z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.002 &nbsp; 0.000 &nbsp; 0.002Now that&#39;s 250 times faster. That&#39;s worth talking about. The reason is that the interpreter does nothing here, compiled code does all the work. No black magic. Let&#39;s see if this is limited to sums or we can see the same effect again  First with the for loop.  &gt; system.time({x = z; &nbsp;for (i in 1:length(z)) x[i] = x[i]^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.110 &nbsp; 0.030 &nbsp; 2.139Then an *apply type function: &gt; system.time({x = sapply(z, function(x) x^2)})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.476 &nbsp; 0.021 &nbsp; 2.496A tad slower, not sure if it is significant. &gt; system.time({x = z^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 0.003 &nbsp; 0.003 &nbsp; 0.006400X faster. Now you get my attention. To do this right, one would have to put some confidence intervals around these numbers, but out of experience using R and knowing a little about R internals and compiler and interpreter technology, I am confident the final answer will be that for or apply, it doesn&#39;t really matter. As a matter of programming style, I believe apply functions to be far superior. I wrote a whole package using I think only two for loops which seemed absolutely necessary. Speed is not the argument though.        Anti-tip #2: Don&#39;t use nested loopsThis is a particularly pernicious anti-tip. The previous one would have resulted in people wasting time to remove loops just to find out that their program was about as slow, but likely shorter and easier to understand. In this case the anti-tip discourages a very useful R optimization technique: optimizing only the innermost loop to reap most of the speed benefits. Let&#39;s see this in two steps. First there is absolutely nothing wrong with nested loops. They are as slow as single loops with the same number of iterations:  &gt; system.time({x = rnorm(10^6); I = numeric(10^6); &nbsp;  for (i in 1:10^6) {k = sample(I, 1); x[k] = x[k]^2}})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 7.589 &nbsp; 0.248 &nbsp; 7.837&nbsp;&gt; system.time({x = rnorm(10^6); I = numeric(10^6);     for (i in 1:1000)     for(j in 1:1000) {k = sample(I, 1); x[k] = x[k]^2}})   user  system elapsed   7.486   0.233   7.770 With that notion put to rest, let&#39;s see the fast inner loop approach in action. This is with two loops:     &gt; M = matrix(rnorm(10^6), ncol = 1000)&gt; system.time({for (i in 1:1000) for (j in 1:1000) M[i,j] = -M[i,j]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 2.369 &nbsp; 0.041 &nbsp; 2.410&nbsp;And this is with the inner loop replaced by a vectorized operation:   &gt; system.time({for (i in 1:1000) M[i,] = -M[i,]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.028 &nbsp; 0.001 &nbsp; 0.030&nbsp;80X faster! You may say: yes but you don&#39;t have nested loops any more. That is not the reason why it is faster as the previous pair of examples showed. The reason is that the interpreter is going through only thousands of steps, while millions of steps take place in compiled code. Once you have given a 1000X &quot;break&quot; to the interpreter, that&#39;s enough to approach C speeds. Not completely    &gt; system.time({M = -M})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.003 &nbsp; 0.000 &nbsp; 0.004&nbsp;If you had 10 nested loops and the innermost required a large enough amount of work, say 1000 operations as a rule of thumb, then optimizing away that innermost loop would be enough to give a considerable boost. You would still have 9 nested loops and it would approach C speeds. Nesting is not the problem, the problem is compiled vs interpreted code. The important message is that, depending on the algorithm, you may have to replace with a fast library function or, &nbsp;at worst, rewrite in C only a small fraction of your code.&nbsp;    " />
<meta property="og:description" content="Not all R tips are equally good. Let&#39;s set the record straight. Anti-tip #1: For loops are slower than functions in the apply familyWhy should that be the case? Let&#39;s see what the R interpreter has to say about it. Let&#39;s get some numbers to chew on first:  z = rnorm(10^6)For loop first: &gt; system.time({x = 0; for(y in z) x = x + y})user &nbsp;system elapsed0.521 &nbsp; 0.004 &nbsp; 0.526To avoid the explicit loop a good match here is the Reduce function, which may be not exactly in the apply family, but it&#39;s faster than several attempts I made using those functions.      &gt; system.time({x = Reduce(&#39;+&#39;, z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.461 &nbsp; 0.030 &nbsp; 0.491Faster, but not by much.      The true tip: use C.      &gt; system.time({x = sum(z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.002 &nbsp; 0.000 &nbsp; 0.002Now that&#39;s 250 times faster. That&#39;s worth talking about. The reason is that the interpreter does nothing here, compiled code does all the work. No black magic. Let&#39;s see if this is limited to sums or we can see the same effect again  First with the for loop.  &gt; system.time({x = z; &nbsp;for (i in 1:length(z)) x[i] = x[i]^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.110 &nbsp; 0.030 &nbsp; 2.139Then an *apply type function: &gt; system.time({x = sapply(z, function(x) x^2)})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.476 &nbsp; 0.021 &nbsp; 2.496A tad slower, not sure if it is significant. &gt; system.time({x = z^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 0.003 &nbsp; 0.003 &nbsp; 0.006400X faster. Now you get my attention. To do this right, one would have to put some confidence intervals around these numbers, but out of experience using R and knowing a little about R internals and compiler and interpreter technology, I am confident the final answer will be that for or apply, it doesn&#39;t really matter. As a matter of programming style, I believe apply functions to be far superior. I wrote a whole package using I think only two for loops which seemed absolutely necessary. Speed is not the argument though.        Anti-tip #2: Don&#39;t use nested loopsThis is a particularly pernicious anti-tip. The previous one would have resulted in people wasting time to remove loops just to find out that their program was about as slow, but likely shorter and easier to understand. In this case the anti-tip discourages a very useful R optimization technique: optimizing only the innermost loop to reap most of the speed benefits. Let&#39;s see this in two steps. First there is absolutely nothing wrong with nested loops. They are as slow as single loops with the same number of iterations:  &gt; system.time({x = rnorm(10^6); I = numeric(10^6); &nbsp;  for (i in 1:10^6) {k = sample(I, 1); x[k] = x[k]^2}})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 7.589 &nbsp; 0.248 &nbsp; 7.837&nbsp;&gt; system.time({x = rnorm(10^6); I = numeric(10^6);     for (i in 1:1000)     for(j in 1:1000) {k = sample(I, 1); x[k] = x[k]^2}})   user  system elapsed   7.486   0.233   7.770 With that notion put to rest, let&#39;s see the fast inner loop approach in action. This is with two loops:     &gt; M = matrix(rnorm(10^6), ncol = 1000)&gt; system.time({for (i in 1:1000) for (j in 1:1000) M[i,j] = -M[i,j]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 2.369 &nbsp; 0.041 &nbsp; 2.410&nbsp;And this is with the inner loop replaced by a vectorized operation:   &gt; system.time({for (i in 1:1000) M[i,] = -M[i,]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.028 &nbsp; 0.001 &nbsp; 0.030&nbsp;80X faster! You may say: yes but you don&#39;t have nested loops any more. That is not the reason why it is faster as the previous pair of examples showed. The reason is that the interpreter is going through only thousands of steps, while millions of steps take place in compiled code. Once you have given a 1000X &quot;break&quot; to the interpreter, that&#39;s enough to approach C speeds. Not completely    &gt; system.time({M = -M})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.003 &nbsp; 0.000 &nbsp; 0.004&nbsp;If you had 10 nested loops and the innermost required a large enough amount of work, say 1000 operations as a rule of thumb, then optimizing away that innermost loop would be enough to give a considerable boost. You would still have 9 nested loops and it would approach C speeds. Nesting is not the problem, the problem is compiled vs interpreted code. The important message is that, depending on the algorithm, you may have to replace with a fast library function or, &nbsp;at worst, rewrite in C only a small fraction of your code.&nbsp;    " />
<link rel="canonical" href="http://piccolboni.info/2012/10/r-anti-tips.html" />
<meta property="og:url" content="http://piccolboni.info/2012/10/r-anti-tips.html" />
<meta property="og:site_name" content="Antonio Piccolboni" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-10-18T00:00:00-07:00" />
<link rel="next" href="http://piccolboni.info/2013/05/three-microblogs-ascetic-programmer.html" title="Three microblogs: The Ascetic Programmer, Science in Crisis and Data Science Matters." />
<link rel="prev" href="http://piccolboni.info/2012/05/essential-r-packages.html" title="The essential R packages" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "R anti-tips",
    "datePublished": "2012-10-18T00:00:00-07:00",
    "description": "Not all R tips are equally good. Let&#39;s set the record straight. Anti-tip #1: For loops are slower than functions in the apply familyWhy should that be the case? Let&#39;s see what the R interpreter has to say about it. Let&#39;s get some numbers to chew on first:  z = rnorm(10^6)For loop first: &gt; system.time({x = 0; for(y in z) x = x + y})user &nbsp;system elapsed0.521 &nbsp; 0.004 &nbsp; 0.526To avoid the explicit loop a good match here is the Reduce function, which may be not exactly in the apply family, but it&#39;s faster than several attempts I made using those functions.      &gt; system.time({x = Reduce(&#39;+&#39;, z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.461 &nbsp; 0.030 &nbsp; 0.491Faster, but not by much.      The true tip: use C.      &gt; system.time({x = sum(z)})  &nbsp; &nbsp;user &nbsp;system elapsed  &nbsp; 0.002 &nbsp; 0.000 &nbsp; 0.002Now that&#39;s 250 times faster. That&#39;s worth talking about. The reason is that the interpreter does nothing here, compiled code does all the work. No black magic. Let&#39;s see if this is limited to sums or we can see the same effect again  First with the for loop.  &gt; system.time({x = z; &nbsp;for (i in 1:length(z)) x[i] = x[i]^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.110 &nbsp; 0.030 &nbsp; 2.139Then an *apply type function: &gt; system.time({x = sapply(z, function(x) x^2)})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 2.476 &nbsp; 0.021 &nbsp; 2.496A tad slower, not sure if it is significant. &gt; system.time({x = z^2})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp; 0.003 &nbsp; 0.003 &nbsp; 0.006400X faster. Now you get my attention. To do this right, one would have to put some confidence intervals around these numbers, but out of experience using R and knowing a little about R internals and compiler and interpreter technology, I am confident the final answer will be that for or apply, it doesn&#39;t really matter. As a matter of programming style, I believe apply functions to be far superior. I wrote a whole package using I think only two for loops which seemed absolutely necessary. Speed is not the argument though.        Anti-tip #2: Don&#39;t use nested loopsThis is a particularly pernicious anti-tip. The previous one would have resulted in people wasting time to remove loops just to find out that their program was about as slow, but likely shorter and easier to understand. In this case the anti-tip discourages a very useful R optimization technique: optimizing only the innermost loop to reap most of the speed benefits. Let&#39;s see this in two steps. First there is absolutely nothing wrong with nested loops. They are as slow as single loops with the same number of iterations:  &gt; system.time({x = rnorm(10^6); I = numeric(10^6); &nbsp;  for (i in 1:10^6) {k = sample(I, 1); x[k] = x[k]^2}})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 7.589 &nbsp; 0.248 &nbsp; 7.837&nbsp;&gt; system.time({x = rnorm(10^6); I = numeric(10^6);     for (i in 1:1000)     for(j in 1:1000) {k = sample(I, 1); x[k] = x[k]^2}})   user  system elapsed   7.486   0.233   7.770 With that notion put to rest, let&#39;s see the fast inner loop approach in action. This is with two loops:     &gt; M = matrix(rnorm(10^6), ncol = 1000)&gt; system.time({for (i in 1:1000) for (j in 1:1000) M[i,j] = -M[i,j]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 2.369 &nbsp; 0.041 &nbsp; 2.410&nbsp;And this is with the inner loop replaced by a vectorized operation:   &gt; system.time({for (i in 1:1000) M[i,] = -M[i,]})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.028 &nbsp; 0.001 &nbsp; 0.030&nbsp;80X faster! You may say: yes but you don&#39;t have nested loops any more. That is not the reason why it is faster as the previous pair of examples showed. The reason is that the interpreter is going through only thousands of steps, while millions of steps take place in compiled code. Once you have given a 1000X &quot;break&quot; to the interpreter, that&#39;s enough to approach C speeds. Not completely    &gt; system.time({M = -M})&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;&nbsp; 0.003 &nbsp; 0.000 &nbsp; 0.004&nbsp;If you had 10 nested loops and the innermost required a large enough amount of work, say 1000 operations as a rule of thumb, then optimizing away that innermost loop would be enough to give a considerable boost. You would still have 9 nested loops and it would approach C speeds. Nesting is not the problem, the problem is compiled vs interpreted code. The important message is that, depending on the algorithm, you may have to replace with a fast library function or, &nbsp;at worst, rewrite in C only a small fraction of your code.&nbsp;    ",
    "url": "http://piccolboni.info/2012/10/r-anti-tips.html"
  }
</script>
<!-- End Jekyll SEO tag -->
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Antonio Piccolboni</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about">About me</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/contact">Contact</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/projects">Projects</a>
          
        
          
        
          
          <a class="page-link" href="/speaking">Speaking</a>
          
        
          
          <a class="page-link" href="/writing">Writing</a>
          
        
        <a class="page-link" href="https://feedburner.google.com/fb/a/mailverify?uri=piccolboni/qdqo&amp;loc=en_US">Subscribe</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">R anti-tips </h1>
    <p class="post-meta">Oct 18, 2012</p>
  </header>

  <article class="post-content">
    <div class='post'>
Not all R tips are equally good. Let's set the record straight. <br /><!--more--><a name='more'></a><h3></h3><h3>Anti-tip #1: For loops are slower than functions in the apply family</h3>Why should that be the case? Let's see what the R interpreter has to say about it. Let's get some numbers to chew on first:  <br /><pre class="brush:r">z = rnorm(10^6)</pre>For loop first: <br /><pre class="brush:r">&gt; system.time({x = 0; for(y in z) x = x + y})<br />user &nbsp;system elapsed<br />0.521 &nbsp; 0.004 &nbsp; 0.526<br /></pre>To avoid the explicit loop a good match here is the Reduce function, which may be not exactly in the apply family, but it's faster than several attempts I made using those functions.      <br /><pre class="brush:r">&gt; system.time({x = Reduce('+', z)})<br />  &nbsp; &nbsp;user &nbsp;system elapsed<br />  &nbsp; 0.461 &nbsp; 0.030 &nbsp; 0.491</pre>Faster, but not by much.      The true tip: use C.      <br /><pre class="brush:r">&gt; system.time({x = sum(z)})<br />  &nbsp; &nbsp;user &nbsp;system elapsed<br />  &nbsp; 0.002 &nbsp; 0.000 &nbsp; 0.002</pre>Now that's 250 times faster. That's worth talking about. The reason is that the interpreter does nothing here, compiled code does all the work. No black magic. Let's see if this is limited to sums or we can see the same effect again  First with the for loop.  <br /><pre class="brush:r">&gt; system.time({x = z; &nbsp;for (i in 1:length(z)) x[i] = x[i]^2})<br />&nbsp; &nbsp;user &nbsp;system elapsed<br />&nbsp; 2.110 &nbsp; 0.030 &nbsp; 2.139</pre>Then an *apply type function: <br /><pre class="brush:r">&gt; system.time({x = sapply(z, function(x) x^2)})<br />&nbsp; &nbsp;user &nbsp;system elapsed<br />&nbsp; 2.476 &nbsp; 0.021 &nbsp; 2.496</pre>A tad slower, not sure if it is significant. <br /><pre class="brush:r">&gt; system.time({x = z^2})<br />&nbsp; &nbsp;user &nbsp;system elapsed<br />&nbsp; 0.003 &nbsp; 0.003 &nbsp; 0.006</pre>400X faster. Now you get my attention. To do this right, one would have to put some confidence intervals around these numbers, but out of experience using R and knowing a little about R internals and compiler and interpreter technology, I am confident the final answer will be that for or apply, it doesn't really matter. As a matter of programming style, I believe apply functions to be far superior. I wrote a whole package using I think only two for loops which seemed absolutely necessary. Speed is not the argument though.      <br /><br /><h3>  Anti-tip #2: Don't use nested loops</h3>This is a particularly pernicious anti-tip. The previous one would have resulted in people wasting time to remove loops just to find out that their program was about as slow, but likely shorter and easier to understand. In this case the anti-tip discourages a very useful R optimization technique: optimizing only the innermost loop to reap most of the speed benefits. Let's see this in two steps. First there is absolutely nothing wrong with nested loops. They are as slow as single loops with the same number of iterations:  <br /><pre class="brush:r">&gt; system.time({x = rnorm(10^6); I = numeric(10^6); &nbsp;<br />  for (i in 1:10^6) {k = sample(I, 1); x[k] = x[k]^2}})<br />&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;<br />&nbsp; 7.589 &nbsp; 0.248 &nbsp; 7.837&nbsp;<br /><br />&gt; system.time({x = rnorm(10^6); I = numeric(10^6);   <br />  for (i in 1:1000) <br />    for(j in 1:1000) {k = sample(I, 1); x[k] = x[k]^2}})<br />   user  system elapsed <br />  7.486   0.233   7.770 </pre>With that notion put to rest, let's see the fast inner loop approach in action. This is with two loops:     <br /><pre class="brush:r">&gt; M = matrix(rnorm(10^6), ncol = 1000)<br />&gt; system.time({for (i in 1:1000) for (j in 1:1000) M[i,j] = -M[i,j]})<br />&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;<br />&nbsp; 2.369 &nbsp; 0.041 &nbsp; 2.410&nbsp;</pre>And this is with the inner loop replaced by a vectorized operation:   <br /><pre class="brush:r">&gt; system.time({for (i in 1:1000) M[i,] = -M[i,]})<br />&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;<br />&nbsp; 0.028 &nbsp; 0.001 &nbsp; 0.030&nbsp;</pre>80X faster! You may say: yes but you don't have nested loops any more. That is not the reason why it is faster as the previous pair of examples showed. The reason is that the interpreter is going through only thousands of steps, while millions of steps take place in compiled code. Once you have given a 1000X "break" to the interpreter, that's enough to approach C speeds. Not completely    <br /><pre class="brush:r">&gt; system.time({M = -M})<br />&nbsp; &nbsp;user &nbsp;system elapsed&nbsp;<br />&nbsp; 0.003 &nbsp; 0.000 &nbsp; 0.004&nbsp;</pre>If you had 10 nested loops and the innermost required a large enough amount of work, say 1000 operations as a rule of thumb, then optimizing away that innermost loop would be enough to give a considerable boost. You would still have 9 nested loops and it would approach C speeds. Nesting is not the problem, the problem is compiled vs interpreted code. The important message is that, depending on the algorithm, you may have to replace with a fast library function or, &nbsp;at worst, rewrite in C only a small fraction of your code.&nbsp;    </div>

  </article>

  <div class="SendComment">
    <a href="mailto:antonio@piccolboni.info?subject=R anti-tips &body=http://piccolboni.info/2012/10/r-anti-tips.html" target="_top">Email the author</a> or <a href="http://via.hypothes.is/http://piccolboni.info//2012/10/r-anti-tips.html">annotate with hypothes.is</a>
  </div>
  <div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */

var disqus_config = function () {
    this.page.url = "http://piccolboni.info//2012/10/r-anti-tips.html";
    this.page.identifier = "/2012/10/r-anti-tips";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//piccolbo.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>

      </div>
    </div>
    <footer class="site-footer">

  <div class="wrapper">

    <div class="PageNavigation">
      
        <a class="prev" href="/2012/05/essential-r-packages.html">&laquo;    The essential R packages</a>
      
      
        <a class="next" href="/2013/05/three-microblogs-ascetic-programmer.html">Three microblogs: The Ascetic Programmer, Science in Crisis and Data Science Matters. &raquo;</a>
      
    </div>

  </div>

</footer>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-7018175-5', 'piccolboni.info');
  ga('send', 'pageview');

</script>

  </body>

</html>
