---
layout: post
title: "Suffix Array construction with mapreduce"
date: 2010-08-11
comments: false
---

<div class='post'>
It turns out that one of the most recent and simplest algorithms for this problem (DC3) is based on well understood building blocks like filtering, sorting and ranking and thus amenable to a mapreduce implementation.<br /><a name='more'></a>For this post I was planning on providing a complete implementation, not just a sketch. That put me on the quest for the ideal mapreduce idiom, elegant enough to present in a blog but also executable. I hope to be able to write about that in a separate post, but for now I want to share, without further ado and in plain English, the core ideas of DC3 for mapreduce.<br /><br /><br /><span class="Apple-style-span" style="font-size: medium;">Introduction</span><br />Suffix trees and their space-saving cousins, suffix arrays, are the swiss army knife of string algorithms. The book "Algorithms on Strings, Trees and Sequences" by D. Gusfield includes two chapters devoted to different application of suffix trees. Just as an example, suffix trees allow to compute the longest common substring (LCS) of two strings in time \(O(N + M)\), with \(N\) and \(M\) the lengths of the two strings â€” yes, proportional to the time necessary just to read the input. If you think that's not impressive, Don Knuth himself had conjectured that to be impossible. While they are more directly applicable to exact problems, like LCS or exact repeats, they play a crucial role in algorithms for approximate problems, like aligning two genomes. Actually, I believe this is the application for which the largest suffix arrays have been built. <a href="http://www.genomenewsnetwork.org/articles/02_01/Sizing_genomes.shtml">Genomes can be big</a>, but the related suffix arrays can stil be built in RAM. If we could create suffix arrays via mapreduce we could go a lot bigger, and maybe create a suffix array of a significant portion of the textual internet. How could that be useful? Imagine you have a long phrase or paragraph, longer than can be Googled. Find all the occurrences of that paragraph in time proportional to the number of occurrences -- yes, once the suffix array is built the length of the query string or the text to be searched are irrelevant. That would make it feasible to analyze how content is syndicated, quoted or plagiarized, track the evolution of so-called <i>memes</i>, with applications such as conversation tracking and merging (<a href="http://backtype.com/">backtype</a> and the now shuttered <a href="http://dotspots.com/">dotspots</a> come to mind) or copyright protection. Suffix array do not directly solve this problem, but they come pretty close as explained in this paper: <i>Computing Longest Common Substrings Via Suffix Arrays</i> by Maxim A. Babenko and Tatiana A. Starikovskaya. On the other hand, suffix arrays take more space than commonplace inverted indexes, even if very clever <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.98.8367&amp;rep=rep1&amp;type=pdf">compressed suffix arrays</a> exist that improve drastically on this point. Inverted indexes are term oriented, so they are appropriate for keyword oriented searches, and they can be used for phrase searches, but think for example of the phase "Circle of life": the longer the phrase and the more common the terms, the harder it gets. Jeff Dean of Google <a href="http://www.doublecloud.org/2010/11/what-lessons-you-can-learn-from-google-on-building-infrastructure/">reports</a> such a query might require 30GB of I/O to answer. Suffix arrays don't even know what terms are: they are meant for phrase search.<br /><br /><br /><span class="Apple-style-span" style="font-size: medium;">The algorithm</span><br /><br />Without further ado, to the mapreduce suffix array construction algorithm, <i>sans</i> map reduce. This is modeled after the original DC3 paper.&nbsp;&nbsp;First let's recall that a suffix array is nothing but a sorted permutation of all suffixes of a string. We will represent the input string as a list of pairs \((i, c)\), where \(i\) is a position and \(c\) the character at that position. I know this sounds wasteful, but it is anyway smaller than the output, can be seen as a temporary representation and allows a simpler implementation. The output is a list of pairs \((i, j)\) which means that the suffix starting at position \(i\) is the \(j^{th}\) suffix in lexicographic order. The first step is to divide the problem in a somewhat curious 1/3, 2/3 split (a more intuitive 1/2, 1/2 split is possible but leads to significant complications in a later phase). Let's consider all the positions for which \(i \mod 3 = k\) with \(k \in \{0,1,2\}\) and define the sets of positions \(P_k\). Now put \(P_0\) on a side and do some work on the other two. Consider all the triples of characters starting at positions in \(P_1\). Here we are performing a change of alphabet, so consider the triples as characters. Thus \(P_1\) corresponds to the string \(s_1\) on this triple alphabet. \(s_2\) is defined likewise and \(s= s_1 + s_2\). We want to obtain a suffix array for the string \(s\). If all characters in the triple alphabet are distinct, that is sorting them ends with no ties, the sorting produces also a suffix array. If not, we use the sorting to replace the triples with their rank (this is to control the growth of the alphabet and bound it with the string length). We then call the algorithm recursively on this shorter string on a larger alphabet (for this reason, eventually, there will be no need for the recursive call). We can now assume we have a suffix array for the string \(s\), that is for the suffixes at the positions \(P_1 \cup P_2\). We can use those to efficiently sort the suffixes starting at positions in \(P_0\). Let's denote a suffix starting at position \(i\) with \(S_i\), then we observe that \(S_i \leq S_j \iff (c_i, S_{i+1}) \leq (c_j, S_{j+1})\) where the order of pairs \((c, S)\) is defined by comparing the first element \(c\) first then the second, the suffix \(S\) (lexicographically) only if there is a tie from the first comparison. Since we are working on \(P_0\), we already know the relative order of \(S_{i+1}\) and \(S_{j+1}\) because their starting positions are in \(P_1\). Now we have sorted separately suffixes in \(P_0\) and suffixes in \(P_1 \cup P_2\) and we just need to merge the two to obtain the overall suffix array. Let's say we are comparing \(S_i\) and \(S_j\) with \(i \in P_0\) and \(j \in P_1\). Then we just need to compare \((c_i,S_{i+1})\) and \((c_j,S_{j+1})\). Those suffixes are in \(P_1\) and \(P_2\) respectively, so we know their relative order already. If &nbsp; \(i \in P_0\) and \(j \in P_2\) then we resort to comparing \((c_ic_{i+1}, S_{i+2})\) and \((c_ic_{j+1}, S_{j+2})\). In this case the suffixes are in \(P_2\) and \(P_1\) respectively, so again we know their relative order. This completes the description of the algorithm, closely rephrased from the original with slightly more accessible notation, I hope. Here is an example. Let's say our input is the word "mississippi", represented like<br /><br /><br /><pre>0 &nbsp; &nbsp; &nbsp; m<br />1 &nbsp; &nbsp; &nbsp; i<br />2 &nbsp; &nbsp; &nbsp; s<br />3 &nbsp; &nbsp; &nbsp; s<br />4 &nbsp; &nbsp; &nbsp; i<br />5 &nbsp; &nbsp; &nbsp; s<br />6 &nbsp; &nbsp; &nbsp; s<br />7 &nbsp; &nbsp; &nbsp; i<br />8 &nbsp; &nbsp; &nbsp; p<br />9 &nbsp; &nbsp; &nbsp; p<br />10 &nbsp; &nbsp; &nbsp;i<br /></pre><br /><br />Then \(S_0\) is<br /><br /><pre>0 &nbsp; &nbsp; &nbsp; mis<br />1 &nbsp; &nbsp; &nbsp; sis<br />2 &nbsp; &nbsp; &nbsp; sip<br />3 &nbsp; &nbsp; &nbsp; pi_<br /></pre><br /><br />where "_" is just a filler. This is \(S\)<br /><br /><br /><pre>0 &nbsp; &nbsp; &nbsp; iss<br />1 &nbsp; &nbsp; &nbsp; iss<br />2 &nbsp; &nbsp; &nbsp; ipp<br />3 &nbsp; &nbsp; &nbsp; i__<br />4 &nbsp; &nbsp; &nbsp; ssi<br />5 &nbsp; &nbsp; &nbsp; ssi<br />6 &nbsp; &nbsp; &nbsp; ppi<br /></pre><br /><br />Obviously there are ties, so we need to perform the alphabet representation change a make a recursive call to get the suffix array for \(S\), which is<br /><br /><br /><pre>0 &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; i__<br />1 &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; ipp<br />2 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; iss<br />3 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; iss<br />4 &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; ppi<br />5 &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; ssi<br />6 &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; ssi<br /></pre><br />The third field is not necessary, but I left it in for clarity here. Now we need to sort \(S_0\) with the help of the suffix array for \(S0\), but there are no ties in this case so it's straightforward. If there were any, let's say between position \(a\) and \(b\), we would just have to look up the rank of positions \(a\) and \(b\) in \(S\) (a clarification: the original positions where \(3a\) and \(3b\) and \(3a+1\) and \(3b+1\) resp, but every time we go down the recursion we "compress" the position range)<br /><br /><br /><pre>0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; mis<br />1 &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; pi_<br />2 &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; sip<br />3 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; sis<br /></pre><br /><br />Now we need to merge these two suffix arrays. Again, there is no ambiguity in this case, but if there were we would just have to look<br /><span class="Apple-style-span" style="font-size: medium;">Map Reduce version</span><br /><br />At this point the mapreduce-savvy reader will have already noticed that none of the operations above seems impossible to implement effectively in mapreduce. Let's review them. Creating the triples can be expressed in an SQL like language that is accepted by hive and translated into map reduce jobs.<br /><br /><br /><pre class="brush: sql">from S S1 join S S2 on (S1.i + 1 = S2.i) join S S3 on (S2.i + 1 = S3.i)<br />insert overwrite P<br />select S1.i/3 as i, S1.i mod 3 as m, concat(S1.c, S2.c, S3.c) as c<br /></pre><br /><br />The mod 3 field is there to enable a later step.<br />Testing whether there duplicated triples is trivial, but just for completeness:<br /><br /><br /><pre class="brush: sql">select * (from P insert select P.c as c, count(1) as n group by P.c) counts where counts.n &gt; 1<br /></pre><br /><br />If the output of this query is empty, we just need to sort P and we are done. So a word on what it means to sort in map reduce. We are not talking about the internal sorting that happens as part of the map reduce process, but a global sort that is the goal of the computation. Since reducers are writing on multiple files, we can not scalably have one sorted file as the output, but only a directory that is organized in a way that is equivalent to sorting. The accepted way to achieve this is described in the Terasort paper and it works as follow:<br /><ol><li>keys are divided in the output files by non-overlapping ranges</li><li>the name of the files denote the range that is covered by a file</li><li>the keys are sorted within each file</li><li>this is achieved writing a custom partitioner</li></ol>This approach also allows us to perform the necessary alphabet change, which is just a way of efficiently encoding the triples. As we sort the data, instead of outputting the triple we output the position in the file plus the starting position for the range encompassed by that file. We also need to store this mapping to reverse the triple mapping later on. Let's assume that the table \(P\) has been processed this way<br />In the next step we perform the 1/3, split 2/3. We included the position mod 3 in the previous step preparing for this one<br /><br /><pre class="brush: sql">from P insert overwrite &nbsp;P0 select P.i, P.c where P.m = 0<br />from P insert overwrite P12 select if P.i, P.c where P.m &lt;&gt; 0<br /></pre><br />Now we perform a recursive call on P12 (in a practical implementation, we will switch at some point to an in memory algorithm).<br />To sort the \(P_0\) positions we need to join the characters in \(P_0\) with the suffixes in \(P_1\) and then sort based on a custom comparison operator.<br /><br />The final merge is similar, but requires multiple joins to gather together the necessary information and a final sort based on more involved custom comparison. Let's look at each step in detail.<br /><br /><pre class="brush: sql">from S S1 join S S2 on (S1.i + 1 = S2.i) join S S3 on (S2.i + 1 = S3.i)<br />insert overwrite P12<br />select &nbsp;S1.i/3 if(i mod 3 = 1, 0, offset), S1.c, S2.c, S3.c where i mod3 != 0<br /></pre></div>
