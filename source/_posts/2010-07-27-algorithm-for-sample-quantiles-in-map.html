---
layout: post
title: "An algorithm for sample quantiles in map reduce"
date: 2010-07-27
comments: false
---

<div class='post'>
A simple but often occurring problem is computing <i>sample quantiles</i>, sometimes named <i>top $k$ elements</i>, in a large data set. Here I show a solution for the MapReduce model of computation.<br /><!--more--><a name='more'></a><br />The standard in memory algorithm for this problem is similar to quicksort, with the main difference that only one branch of the recursion is followed. An important detail is that if we are looking for the top $k$ element, after the pivoting phase we might still be looking for it among the $m$ elements higher than the pivot, if $m \geq k$, but if that's not the case then we need to look for the top $k-m$ element among the elements smaller than the pivot. This is slightly more complicated to state in terms of quantiles, but the idea is the same. To port this algorithm to the map reduce model, we need to avoid pivoting, which requires random access, and adopt a style more similar to that of <i>streaming algorithms</i>. Pivoting is replaced by a combination of counting and filtering. In each iteration, we maintain an upper and  lower bound for the quantile of interest. To refine it, we split that interval in half at a threshold $t$. We count how many data points are above the threshold. If that indicates that the target quantile is higher than the threshold, it becomes our new lower bound, otherwise we update the upper bound. Now we could simply go for a new pass, until upper and lower bound identify only one value in the sample (it could be repeated multiple times though), but if writing is not too costly and we have spare disk space, we can write out only the elements that are in between the upper and lower bound, bringing the complexity from $O(n \log(n))$ to $O(n)$. In the filtered sample we will be looking for a different quantile.<br /><br />To add some detail, this is how the counting happens (using a combiner is mandatory for this algorithm, or the only two reducers will have to process the whole dataset):<br /><pre class="brush: python">def map(v):<br />  if (v <= t):<br />    return [(T, 1)]<br />  else:<br />    return [(F, 1)]<br /></pre><pre class="brush: python">def reduce(list):<br />  sum = 0<br />  for (is_low, count) in list:<br />    sum += count<br />  return[(is_low, sum)]<br /></pre>This is the filtering, just for completeness sake. <pre class="brush: python">def map(v):<br />  if (lower <= v < upper)<br />    return [v]<br />  else:<br />    return []<br /></pre>And this is the update rule for the bounds and quantile values: <pre class="brush: python">def bounds(u, l, t, ca, cb, q):<br />  # u, l: quantile upper and lower bounds<br />  # t: threshold<br />  # ca, cb: count of values above and below threshold<br />  # q: desired quantile<br />  n = ca + cb<br />  topk = (1 - q) * n<br />  if topk <= ca:<br />    l = t<br />    q =  1 - topk/ca<br />  else:<br />    u = t<br />    q = 1 - (topk - ca)/cb<br />  t = floor(u + l / 2)<br />  return (u, l, t, q)<br /></pre>There is a little more work to glue everything together, but it should be clear at this point. The algorithm terminates when the max and min of the current filtered sample are equal. An optimization is to use more than one threshold during each iteration. This allows to trade iterations with memory usage. More precisely, we could maintain as many bins as memory allows and perform the counting bin by bin. Once this is done, we pick the bin that contains the quantile, split its range into equal sized bins and repeat. Filtering works exactly the same way as above.   <p>A couple of observations about the applications of this algorithm. Often we are trying to estimate a quantile from a distribution from which the data is sampled. In that case, calculating a sample quantile is only the start. As estimates of distribution quantiles, sample quantiles are biased towards the median and without confidence intervals or other measure of variability we don't know anything about their variability. To obtain confidence intervals for any quantile one can use the technique explained <a href="http://turing.une.edu.au/~stat354/notes/node72.html">here</a> and for extreme quantiles <a href="http://cran.r-project.org/web/packages/evir/index.html">special techniques</a> might give better results. In both cases we need to extract sample quantiles as an intermediate step, so the algorithm described here can be useful, but not necessarily from the whole dataset. We might opt for a single pass map reduce subsampling step followed by in memory analysis and get a tight enough confidence interval faster and using fewer resources. The best trade off between precision, speed and resources is application dependent.</p><p>This post was inspired by a job interview question, where we covered in memory algorithms and only hinted at the mapreduce solution, but I thought it would be interesting to write it down.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>jkff</div>
<div class='content'>
Antonio, you may be interested in the QDigest datastructure, which can compute approximate quantiles (and much more) with very little memory, and also has the additivity property - you can combine two QDigest&#39;s for parts of a collection of numbers, giving a QDigest for the whole collection. So I think it&#39;s a perfect fit for mapreduce too.<br /><br />http://www.cs.virginia.edu/~son/cs851/papers/ucsb.sensys04.pdf<br />etc.</div>
</div>
</div>
