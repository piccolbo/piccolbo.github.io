---
layout: post
title: "Bringing relational joins to Rhipe"
date: 2011-04-15
comments: false
---

<div class='post'>
Relational operations are a very common way to express map-reduce computations at a higher level, but Rhipe, an R package for mapreduce, doesn't have any. Let's start to fix this with a basic join function.<br /><br /><!--more--><a name='more'></a><br />This is going to be a little dry and technical, in preparation of better things to come.<br />As I was working on implementing a non-trivial map-reduce algorithm in Rhipe, I realized I needed joins, in the relational sense — Rhipe has an <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rhjoin</span> call but it is unrelated. The not-so-deep reason I needed them is that that's the way I described the algorithm in my <a href="http://piccolboni.info/2010/07/map-reduce-algorithm-for-connected.html">pseudo-code</a>, but is that the only or the best way to do it? I don't know the answer, but it looks like several Hadoop derivatives that try to offer higher level alternatives have joins and a number of other SQL-like features: Hive of course but also Cascading, Cascalog, and Pig. Dumbo has sort of a lower level support for joins in the form of "join keys". While these are hardly independent validations of the use of relational operations for mapreduce, they give me some confort that other people see them as important. In fact, I don't think we have seen enough examples of mapreduce algorithms yet to know which techniques are going to be the most important.<br />Before we get onto the actual code, please bear in mind that this is a very basic join and doesn't use any of the techniques that have been devised to make joins faster and less memory intensive, from secondary keys to map-side joins. I thought it would be premature optimization to try and implement them right away and also Rhipe poses some restrictions on the partitioner, I suspect inherited from Hadoop Streaming, that would have made using them in this context hard. So, without further ado, the code (syntax highlighting is approximate at best, my apologies):<br /><br /><pre class="brush: r">function(<br />         ileftfolder = NULL,<br />         irightfolder = NULL,<br />         ifolder = NULL,<br />         ofolder,<br />         leftouter = F,<br />         rightouter = F,<br />         fullouter = F,<br />         map.left.key,<br />         map.right.key,<br />         map.right.value = function(k, v) v,<br />         map.left.value = function(k, v) v,<br />         reduce.key = function(k, vl, vr) k,<br />         reduce.value = function (k, vl, vr) list(left=vl, right=vr)){if (is.null(ileftfolder)) {<br />    ileftfolder = ifolder}<br />  mapcollect = function(k,v, kfun, vfun, left) rhcollect(kfun(k,v), list(value = vfun(k,v), left = left))<br />  rhex(<br />       rhmr(<br />            map = eval(<br />              substitute(<br />                         if (is.null(ifolder)) {<br />                           expression({<br />                             lapply(seq_along(map.keys), function(i) {<br />                               if(length(grep(paste("^file:", ileftfolder, sep = ""), <br />                                              Sys.getenv("mapred.input.file")))) {<br />                                   mapcollect(map.keys[[i]], map.values[[i]], map.left.key, map.left.value, T)}<br />                                 else {<br />                                   mapcollect(map.keys[[i]], map.values[[i]], map.right.key, map.right.value, F)}<br />                             })})}<br />                         else {<br />                           expression({<br />                             lapply(seq_along(map.keys), function(i) {<br />                               mapcollect(map.keys[[i]], map.values[[i]], map.left.key, map.left.value, T)<br />                               mapcollect(map.keys[[i]], map.values[[i]], map.right.key, map.right.value, F)<br />                             })})},<br />                         list(map.left.key = map.left.key,<br />                              map.right.key = map.right.key,<br />                              map.right.value = map.right.value,<br />                              map.left.value = map.left.value,<br />                              ileftfolder = ileftfolder,<br />                              mapcollect = mapcollect))),<br />            reduce = eval(<br />              substitute(<br />                         expression(<br />                             pre = {<br />                               reduce.split = <br />                                 function(values, left) lapply(values[which(lapply(values, <br />                                                                                   function(x) x$left) == left)], <br />                                                               function(x) x$value)<br />                               all.values = c()},<br />                             reduce = {<br />                               all.values = c(all.values, reduce.values)},<br />                             post = {<br />                               reduce.values.left = reduce.split(all.values, T)<br />                               if(length(reduce.values.left) == 0 &amp;&amp; (rightouter || fullouter)) {<br />                                 reduce.values.left = c(NA)}<br />                               reduce.values.right = reduce.split(all.values, F)<br />                               if(length(reduce.values.right) == 0 &amp;&amp; (leftouter || fullouter)) {<br />                                 reduce.values.right = c(NA)}<br />                               lapply(reduce.values.left,<br />                                      function(x) lapply(reduce.values.right,<br />                                                         function(y) rhcollect(reduce.key.fun(reduce.key, x, y),<br />                                                                               reduce.value(reduce.key, x, y))))<br />                             }),<br />                         list(reduce.key.fun = reduce.key,<br />                              reduce.value = reduce.value,<br />                              leftouter = leftouter,<br />                              rightouter = rightouter,<br />                              fullouter = fullouter<br />                              ))),<br />            combiner = F,<br />            inout = c('sequence','sequence'),<br />            ifolder=c(ileftfolder,irightfolder),<br />            ofolder= ofolder<br />            )<br />       )<br />}</pre><br /><i>Lines 1–15<br /></i> This is the signature. There are left and right input files for regular joins or a single input for self joins. There's an output and then three flags to determine if it's going to be a left, right or full outer join. Then we have two functions, one for the left argument and one for the right argument to the join, to specify the join key (we need both also for a self-join). These functions are called for each key, value pair in the mapper and their output becomes the key for the shuffle and reduce steps. We can also specify which values will be sent into the reduce step from the left input and the right input, but these are optional and default to letting the values go through unmodified. Then we have two more functions that determine the key, value pairs emitted by the reduce phase. They take as arguments the value for the join key, the value from the left input and the value from the right input, of course record by record. The key defaults to simply the join key and the value is a named pair with the left side and the right side simply containing the value from each side resp., sort of an equivalent to SELECT *.<br /><br /><i>Lines 17–18<br /></i> <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rhex</span> executes a job and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rhmr</span> creates the specs for a job. The latter takes several arguments, that we are going to describe in detail<br /><br /><i>Lines 18–41<br /></i> This is the map phase of the job, provided as an R expression. "Expressions" in R are unevaluated expressions. You get a value out of them by using eval and can modify them using substitute, which we use <i>in lieu</i> of passing arguments. For added confusion, substitute returns an expression generator, so you need eval to get again an unevaluated expression. Like, you replace the spark plugs in a car and you are left with a car generator — sounds too good to be true. Passing an expression instead of a function is a choice that the author of Rhipe himself <a href="https://groups.google.com/d/topic/rhipe/KU0fibsMLkk/discussion">explains</a>. More precisely, there are two expressions, one for the join of two inputs and one for the self join. For the first case, it is enough, for each record, to decide which input the current record came from, evaluate the right key and value functions and emit a key, value pair. In the self-join case one has to emit both a left and right key value pair for each record.<br /><br /><i>Lines 42–70<br /></i>This is the reduce phase of the job. The drill about passing an expression and substituting arguments is exactly the same as for map. The expression this time is composed of three sub-expressions. For each key, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">pre</span> is evaluated before the first record, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">reduce</span> several times, one per block of records, and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">post</span> after the last one. Here <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">pre</span> simply defines a function and a variable for later use, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">reduce</span> accumulates all the records and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">post</span> splits left and right side of the join, adds NA entries when necessary for outer joins and emits all the output records with two nested loops, applying the functions in the arguments to create them. <br /><br /><i>Lines 71–74<br /></i>Some additional <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rhmr</span> arguments that specify whether to use a combiner, and format and names of inputs and outputs. The returned value is that returned by <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rhex</span>.<p><br />And that's it, unless you are developing in Rhipe this is not so interesting. But in all of 77 lines we have built a missing component to Rhipe and we'll put it to good use in the next installment.</div>
