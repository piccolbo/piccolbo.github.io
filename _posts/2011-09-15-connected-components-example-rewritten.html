---
layout: post
title: "The connected components example, rewritten using RHadoop/rmr"
date: 2011-09-15
comments: false
---

<div class='post'>
My new implementation of random mate for mapreduce, using the package <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rmr</span> from <a href="http://www.revolutionanalytics.com/">Revolution Analytics</a> open source project <a href="http://github.com/RevolutionAnalytics/RHadoop">RHadoop</a>.<br /><!--more--><a name='more'></a>This story has now three episodes. First, I got interested in how to compute <a href="http://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected components</a> in <a href="http://en.wikipedia.org/wiki/MapReduce">map reduce</a> in a way that works even for large diameter graphs and <a href="http://piccolboni.info/2010/07/map-reduce-algorithm-for-connected.html">proposed an algorithm</a>, in fact a port to map reduce of an old PRAM algorithm. Then I learned <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://ml.stat.purdue.edu/rhipe/">RHIPE</a></span>, a map reduce package for R and <a href="http://piccolboni.info/2011/04/map-reduce-algorithm-for-connected.html">implemented that algorithm</a> using it. Then Revolution Analytics knocked at my door and asked me to work on a similar package and give my best stab at an API that's both easy and powerful. You can read a bit more about <a href="https://github.com/RevolutionAnalytics/RHadoop/wiki/Philosophy">the ideas behind the package</a>, but keep in mind that this is a young project and there is more work to do to turn those lofty goals into reality. You can help by just trying it out and providing feedback or by contributing to it. From documentation to unit tests, to minor features, to very significant ones, there's plenty to do.<br />Granted, clarity and simplicity are in the eye of the beholder and I am hardly unbiased, being the author of the code, the main committer to <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rmr</span> and having Revolution as a client. But I invite you to compare this example with its previous incarnation using <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">RHIPE</span>, namely how the mapreduce jobs are described and invoked, &nbsp;how much less boilerplate code there is and how completely devoid of uncommon R constructs it is, replacing unevaluated expressions and expression substitution with regular functions. Another interesting comparison is with <a href="http://www.hortonworks.com/transitive-closure-in-apache-pig/">this alternate algorithm</a> for the same problem, implemented in a mix of Pig and Python. A number of additional examples can be found in the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rmr</span> <a href="http://github.com/RevolutionAnalytics/RHadoop/wiki/Tutorial">tutorial</a>, including k-means, logistic regression and linear least squares.  Joshua Block of <i>Effective Java</i> fame recommends to "<a href="http://lcsd05.cs.tamu.edu/slides/keynote.pdf">write to your API early and often</a>" (p. 9) and in my mind I had been writing to something like this for a long time, in some respects even before I had heard of mapreduce. I just needed the opportunity and environment to make it happen and I am grateful to Revolution for providing them. But let the <a href="git://gist.github.com/1219908.git">code</a>&nbsp;(git repo) speak:<br /><br /><pre class="brush: r">library(rmr)<br /><br />connected.components = function(graph, forest = NULL, i = 0) {<br />  key.from = function(k,v) keyval(v[['from']], v)<br />  key.to = function(k,v) keyval(v[['to']], v)<br />  if(is.null(forest)) {<br />    ##create trivial forest<br />    forest = mapreduce(<br />      input = graph,<br />      map = function(k, v) list(keyval(v[['from']], NULL), <br />                                keyval(v[['to']], NULL)),<br />      reduce = function(k, vv) keyval(NULL, list(from = k, to = k)))}<br />  ##merge graph and forest<br />  graph.forest = equijoin(leftinput =<br />    equijoin(leftinput = graph,<br />             rightinput = forest,<br />             map.left = key.from,<br />             map.right = key.from,<br />             reduceall = <br />               function(k, vl, vr) <br />                 keyval(NULL, <br />                        list(parentfrom = vr[['to']], <br />                             from = vl[['from']], <br />                             to = vl[['to']]))),<br />    rightinput = forest,<br />    map.left = key.to,<br />    map.right = key.from,<br />    reduceall = function(k, vl, vr) keyval(NULL, <br />                                           list(parentfrom = vl[['parentfrom']], <br />                                                parentto = vr[['to']], <br />                                                from = vl[['from']], <br />                                                to = vl[['to']])))<br />  ##find component merge candidates<br />  if(active.edges.count(graph.forest) &gt; 0) {<br />    forest.update = update.parent(graph.forest, i)<br />    ##depth-reducing step<br />    forest.new = equijoin(input =<br />      ##forest update<br />      equijoin(leftinput = forest,<br />               rightinput = forest.update,<br />               outer = "left",<br />               map.left = key.from,<br />               map.right = key.from,<br />               reduceall = function(k,vl,vr) keyval(NULL, <br />                                                    if(all(is.na(vr))) {vl} <br />                                                    else {vr})),<br />      outer = "left",<br />      map.left = key.to,<br />      map.right = key.from,<br />      reduceall = function(k,vl,vr) keyval(NULL, <br />                                           list(from = vl[['from']], <br />                                                to = if(all(is.na(vr)){vl[['to']]} <br />                                                     else {vr[['to']]})))<br />    ##recursion<br />    connected.components(graph, forest.new, i+1)}<br />  else  forest}<br />  <br />active.edges.count = function(gf) {<br />  from.dfs(mapreduce(input = gf, <br />                     map = function(k,v) <br />                       if(v[['parentfrom']] != v[['parentto']] ) <br />                       keyval(NULL,1) else keyval(NULL, 0), <br />                     reduce = function(k, vv) keyval(NULL, sum(unlist(vv))), <br />                     combine = T))[[1]]$val}<br /><br />update.parent = function(input, iter) {<br />  library(digest)<br />  symmetry.break = function(x,r) {<br />    as.integer(paste("0x", substr(digest(c(x,r)), 1,1), sep = ""))%%2 == 1}<br />  mapreduce(input = input,<br />            map = function(k, v) {<br />              if(v[['parentfrom']] != v[['parentto']]) {<br />                symmetry.from = symmetry.break(v[['parentfrom']], iter);<br />                symmetry.to = symmetry.break(v[['parentto']], iter);<br />                if(symmetry.from != symmetry.to) {<br />                  if(symmetry.from) {<br />                    keyval(v[['parentfrom']],list(from = v[['parentfrom']], <br />                                                  to = v[['parentto']]))}<br />                  else {<br />                    keyval(v[['parentto']], list(from = v[['parentto']], <br />                                                 to = v[['parentfrom']]))}}}},<br />            reduce = function(k, vv) keyval(NULL, vv[[1]]),<br />            combine = F)}<br /><br />random.graph = to.dfs(unique(lapply(1:10,<br />                                    function(i)keyval(NULL, <br />                                                      c(from = sample(1:10,1), <br />                                                        to = sample(1:10,1))))))<br /><br /><br /></pre>One remark to better understand how this code works (you may need to take the <a href="http://github.com/RevolutionAnalytics/RHadoop/wiki/Tutorial">rmr tutorial</a> to really get all the details): the objects returned by mapreduce calls do not directly contain the data but point to it. Since we are potentially working on big data, the data stays on HDFS unless the programmer explicitly requests otherwise. These objects take care of creating temp filenames, cleaning them up when they are not referenced anymore, and can be passed around from mapreduce call to mapreduce call. It is a simple but recurring concern that rmr hopefully takes off the programmer's plate once and for all. The line-by-line description may not be so interesting to you if you are familiar with the old RHIPE based implementation, but here it is for completeness sake.<br /><i>Line 1</i>: Load the library. <br /><i>Line 3</i>: The main function. It takes the graph to analyze, optionally a forest representing a partition into connected components, which start as individual nodes and end up as maximal connected components by the time the algorithm terminates, and an integer. The forest shares the nodes with the input graph and the roots are marked by a self-loop. Forest elements are trees and in this algorithms have depth 1 most of the time, that is it's a forest of stars. The integer argument represents the iteration and is used to generate correlated pseudorandomness across all nodes, details later. <br /><i>Lines 4–5</i>: Nodes are represented by integers and edges by a list with a <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">from</span> and a <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">to</span> element, one per record. These two functions, used over and over again as map functions, set the key to the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">from</span> and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">to</span> node of an edge resp., while leaving the value alone. <br /><i>Lines 6–12</i>: If a forest is not provided as argument, initialize it to the set of all  isolated nodes. Add a self-loop to mark the root. <br /><i>Lines 14–32</i>: merge the graph and the forest so that every node in the graph is labelled with its parent in the forest, that is the component it belongs too. This is implemented with two successive join-like operations, which in turn are implemented as map-reduce jobs. <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rmr</span> takes care of some of the ugly details of performing joins in mapreduce providing equijoins as part of the package. Build from the dev branch to get this feature. <br /><i>Lines 34–53</i>: active edges are edges connecting nodes belonging to different components. If none exists, then components are maximal and the algorithm terminates. The test for active edges is implemented as a separate map-reduce job whereas it could be folded into the forest update job to be described shortly, but we went for modularity here. The forest.update call decides, for each active edge, which components should be merged and how and expresses that as additional edges to be merged into the forest. The next step is formed by two chained equijoins: the inner one, which executes first, merges in the new edges into the forest while keeping the trees trees (invariant: each node has one parent). The outer one transforms each tree, now potentially of depth two after a merger with another tree, into a star. <br /><i>Lines 55–56</i>: recursive call. Keep growing that forest or return it when done. <br /><i>Lines 58–64</i>: count active edges. Works on the merged graph-forest data structure, so it's pretty trivial to check for components that should be merged, that is edges incident on different components. The interesting bit is that this is a potentially very large computation that ends with a single number. That's why we can simply grab that data from HDFS with <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">from.dfs</span> and bring into memory, where it can be used for the termination condition. <br /><i>Lines 66–83</i>: This is the logic that decides which components to actually merge and I think the most technically sophisticated bit (not my idea). If we just tried to merge every pair of components connected by an active edge, mayhem would ensue. The forest would not be a forest anymore, and cycles would be possible. We need to elect "donor" components and "acceptor" components and exclusively merge the former into the latter. That will leave the forest a forest after the merger step is performed. The smart part is the very simple and distributed mechanism employed to decide donors and acceptors. It's a pseudorandom boolean computed as a hash function of the component root node name, which works as component id, and the iteration number (the somewhat convoluted <i>line 70</i> does just that, would love to hear of a simpler way). The latter is included so that the "donor" and "acceptor" assignments change at each iteration and eventually all active edges have a chance to be used for a merger, thus becoming active no more.  <br /><i>Lines 85–88</i>: How to create some test data   <br /><br />If you liked this or anything else piqued your interest, please give <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">rmr</span> a spin and <a href="mailto:antonio@piccolboni.info">let me</a> know of any problems and comments or just new applications and examples.<br /><br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Antonio</div>
<div class='content'>
The R interpreter accepted this code at some point so if I did, I must have forgotten an open one as well. I can&#39;t see either.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
In line 52 you forgot a closing bracket in the if statement?</div>
</div>
<div class='comment'>
<div class='author'>Antonio Piccolboni</div>
<div class='content'>
Thanks for your comments. The random gender assignment is not my idea and comes form the original random mate algorithm for the PRAM. It&#39;s a &quot;symmetry breaking&quot; technique used in parallel programming in other algorithms. The modification you suggest is also suggested at the end of my first writeup. If we switch from two genders to a total order on the nodes, we can get more mergers of components done per iteration.  This implies that the trees representing components can have depth larger than 2, which requires a more powerful and costly flattening phase. It&#39;s a trade off and the best option may depend on the type of graph. The blog post you pointed me to has no time complexity discussion in it or linked to, so I am not in a position to comment on which one is faster.</div>
</div>
<div class='comment'>
<div class='author'>yadog</div>
<div class='content'>
Hey Antonio,<br />Very nice write-up(s). <br /><br />I&#39;m contemplating 2 options for connected-components MR: yours, and Chaser&#39;s (http://chasebradford.wordpress.com/2010/10/23/mapreduce-implementation-for-union-find). <br /><br />I&#39;m trying to understand some tech details, mainly: how come you had to come up with the gender(donator/acceptor) notion, while in the other alg we simply use natural order of the root node IDs?</div>
</div>
</div>
